#pragma once

namespace cswinrt
{
    using namespace std::literals;
    using namespace winmd::reader;

    template <typename...T> struct visit_overload : T... { using T::operator()...; };

    template <typename V, typename...C>
    auto call(V&& variant, C&& ...call)
    {
        return std::visit(visit_overload<C...>{ std::forward<C>(call)... }, std::forward<V>(variant));
    }

    struct writer : indented_writer_base<writer>
    {
        using indented_writer_base::indented_writer_base;

        std::string_view _current_namespace{};
        bool _in_abi_namespace = false;

        writer(std::string_view current_namespace) :
            _current_namespace(current_namespace)
        {
        }

        void write_begin()
        {
            write(R"(// This file was generated by cswinrt.exe

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to

namespace %
{
)", _current_namespace);
        }

        void write_end()
        {
            write("}\n");
        }

        void write_begin_abi()
        {
            write("\nnamespace ABI.%\n{\n", _current_namespace);
            _in_abi_namespace = true;
        }

        void write_end_abi()
        {
            write("}\n");
            _in_abi_namespace = false;
        }

        using indented_writer_base<writer>::write;

        struct generic_args
        {
            std::vector<std::vector<type_semantics>> stack;

            struct guard
            {
                explicit guard(generic_args* owner = nullptr)
                    : _owner(owner)
                {
                }

                ~guard()
                {
                    if (_owner)
                    {
                        _owner->pop();
                    }
                }

                guard(guard&& other)
                    : _owner(other._owner)
                {
                    _owner = nullptr;
                }

                guard& operator=(guard&& other)
                {
                    _owner = std::exchange(other._owner, nullptr);
                    return *this;
                }

                guard& operator=(guard const&) = delete;
                generic_args* _owner;
            };

            [[nodiscard]] auto push(std::pair<GenericParam, GenericParam> const& range)
            {
                if (empty(range))
                {
                    return guard{ nullptr };
                }

                stack.emplace_back(begin(range), end(range));
                return guard{ this };
            }

            [[nodiscard]] auto push(generic_type_instance const& type)
            {
                XLANG_ASSERT(!type.generic_args.empty());
                stack.push_back(type.generic_args);
                return guard{ this };
            }

            auto get(uint32_t index)
            {
                bool is_index{};
                for (auto&& args = rbegin(stack); args != rend(stack); ++args)
                {
                    if (index >= args->size())
                    {
                        continue;
                    }
                    auto& semantics = (*args)[index];
                    auto gt_index = std::get_if<generic_type_index>(&semantics);
                    if (gt_index)
                    {
                        is_index = true;
                        index = gt_index->index;
                        continue;
                    }
                    // Temporary: skip over nested generic type instances 
                    // (e.g, IMapView<K,V> : IIterable<IKeyValuePair<!0,!1>)
                    if (is_index)
                    {
                        auto gt_instance = std::get_if<generic_type_instance>(&semantics);
                        if (gt_instance)
                        {
                            if (index < gt_instance->generic_args.size())
                            {
                                auto nested = gt_instance->generic_args[index];
                                if (std::get_if<generic_type_index>(&nested))
                                {
                                    continue;
                                }
                            }
                        }
                    }
                    return semantics;
                }
                throw_invalid("Could not find generic argument");
            }

            void pop()
            {
                stack.pop_back();
            }
        };

        generic_args generic_args;

        [[nodiscard]] auto push_generic_params(std::pair<GenericParam, GenericParam> const& range)
        {
            return generic_args.push(range);
        }

        [[nodiscard]] auto push_generic_args(generic_type_instance const& type)
        {
            return generic_args.push(type);
        }

        auto get_generic_arg(uint32_t index)
        {
            return generic_args.get(index);
        }

        void write_code(std::string_view const& value)
        {
            for (auto&& c : value)
            {
                if (c == '`')
                {
                    return;
                }
                else
                {
                    write(c);
                }
            }
        }

        using generic_type_name_write = std::function<void(writer & w, uint32_t index)>;
        generic_type_name_write write_generic_type_name_custom{};
        struct write_generic_type_name_guard
        {
            writer& _writer;
            generic_type_name_write _current;
            write_generic_type_name_guard(writer& w, generic_type_name_write current) : 
                _writer(w), _current(current)
            {
                std::swap(_current, _writer.write_generic_type_name_custom);
            }
            ~write_generic_type_name_guard()
            {
                std::swap(_current, _writer.write_generic_type_name_custom);
            }
        };
    };

    struct separator
    {
        writer& w;
        std::string_view _separator{ ", " };
        bool first{ true };

        void operator()()
        {
            if (first)
            {
                first = false;
            }
            else
            {
                w.write(_separator);
            }
        }
    };
}