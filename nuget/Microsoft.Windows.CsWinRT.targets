<!--
***********************************************************************************************
Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <CsWinRTMessageImportance Condition="'$(CsWinRTMessageImportance)' == ''">normal</CsWinRTMessageImportance>
    <CsWinRTCommandVerbosity Condition="'$(CsWinRTMessageImportance)' == 'high'">-verbose</CsWinRTCommandVerbosity>
    <ResolveAssemblyReferencesDependsOn Condition="'$(CsWinRTRemoveWindowsReference)'!='false'">$(ResolveAssemblyReferencesDependsOn);CsWinRTRemoveWindowsReference</ResolveAssemblyReferencesDependsOn>
    <CsWinRTEnabled Condition="'$(CsWinRTEnabled)' == ''">true</CsWinRTEnabled>
    <CsWinRTEnabled Condition="'$(CsWinRTEnabled)' != 'true'">false</CsWinRTEnabled>
    <CsWinRTGenerateProjection Condition="!$(CsWinRTEnabled)">false</CsWinRTGenerateProjection>
    <CsWinRTGenerateProjection Condition="'$(CsWinRTGenerateProjection)' == ''">true</CsWinRTGenerateProjection>
    <AllowUnsafeBlocks Condition="$(CsWinRTEnabled)">true</AllowUnsafeBlocks>

    <!--
      Making sure ResolveAssemblyReferences runs before CoreCompile runs as we have seen it not run
      in WPF scenarios causing for our targeting pack to not get included or conflicts to be resolved.
    -->
    <CoreCompileDependsOn>ResolveAssemblyReferences;CsWinRTIncludeProjection;CsWinRTRemoveWinMDReferences;$(CoreCompileDependsOn)</CoreCompileDependsOn>
    <TrackFileAccess Condition="'$(CsWinRTComponent)' != 'true'">false</TrackFileAccess>
    <CsWinRTAotOptimizerEnabled Condition="'$(CsWinRTAotOptimizerEnabled)' == '' and $([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) >= 6">true</CsWinRTAotOptimizerEnabled>

    <!--
      If the AOT optimizer is enabled, and we're publishing with NativeAOT, automatically set CsWinRTAotExportsEnabled as well.
      Only do this if the property is not already set by the user, so we respect any existing preference.
    -->
    <CsWinRTAotExportsEnabled Condition="'$(CsWinRTAotExportsEnabled)' == '' and '$(CsWinRTAotOptimizerEnabled)' == 'true' and '$(PublishAot)' == 'true'">true</CsWinRTAotExportsEnabled>
    <CsWinRTAotExportsEnabled Condition="'$(CsWinRTAotExportsEnabled)' != 'true'">false</CsWinRTAotExportsEnabled>

    <!-- Set the RCW factory fallback generator to not be opt-in by default -->
    <CsWinRTRcwFactoryFallbackGeneratorForceOptIn Condition="'$(CsWinRTRcwFactoryFallbackGeneratorForceOptIn)' != 'true'">false</CsWinRTRcwFactoryFallbackGeneratorForceOptIn>
    <CsWinRTRcwFactoryFallbackGeneratorForceOptOut Condition="'$(CsWinRTRcwFactoryFallbackGeneratorForceOptOut)' != 'true'">false</CsWinRTRcwFactoryFallbackGeneratorForceOptOut>

    <!--
      These properties are defined in this property group and not in the 'CsWinRTGenerateProjection'
      target, because they are also needed in authoring scenarios (which will not run that target).
    -->
    <CsWinRTExeTFM Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 5">net5.0</CsWinRTExeTFM>
    <CsWinRTExeTFM Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 6">net6.0</CsWinRTExeTFM>
    <CsWinRTExeTFM Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 7">net7.0</CsWinRTExeTFM>
    <CsWinRTExeTFM Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) >= 8">net8.0</CsWinRTExeTFM>
    <CsWinRTExeTFM Condition="'$(CsWinRTExeTFM)' == ''">netstandard2.0</CsWinRTExeTFM>
    <CsWinRTWindowsMetadata Condition="'$(CsWinRTWindowsMetadata)' == ''">$(WindowsSDKVersion.TrimEnd('\'))</CsWinRTWindowsMetadata>
    <CsWinRTWindowsMetadata Condition="'$(CsWinRTWindowsMetadata)' == ''">$(TargetPlatformVersion)</CsWinRTWindowsMetadata>
  </PropertyGroup>

  <ItemGroup>
    <CompilerVisibleProperty Include="CsWinRTAotOptimizerEnabled" />
    <CompilerVisibleProperty Include="CsWinRTAotExportsEnabled" />
    <CompilerVisibleProperty Include="CsWinRTRcwFactoryFallbackGeneratorForceOptIn" />
    <CompilerVisibleProperty Include="CsWinRTRcwFactoryFallbackGeneratorForceOptOut" />
    <CompilerVisibleProperty Include="CsWinRTCcwLookupTableGeneratorEnabled" />
    <CompilerVisibleProperty Include="CsWinRTMergeReferencedActivationFactories" />
    <CompilerVisibleProperty Include="CsWinRTAotWarningLevel" />
  </ItemGroup>

  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.Embedded.targets" Condition="'$(CsWinRTEmbedded)' == 'true'"/>
  
  <Target Name="CsWinRTNet5EOL" Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 5" BeforeTargets="CsWinRTPrepareProjection">
    <Error Text="Support for .NET 5 ended with C#/WinRT 2.0. For .NET 5 support, use C#/WinRT version 1.6.5. See https://github.com/microsoft/CsWinRT/discussions/1232" />
  </Target>

  <Target Name="CsWinRTNet6EOL" Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 6 or $([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 7" BeforeTargets="CsWinRTPrepareProjection">
    <Error Text="Support for .NET 6 and .NET 7 ended with C#/WinRT 2.2. For .NET 6 or .NET 7 support, use C#/WinRT version 2.2.x." />
  </Target>

  <!-- Note this runs before the msbuild editor config file is generated because that is what is used to pass properties to the source generator. -->
  <Target Name="CsWinRTSetGeneratorProperties" BeforeTargets="GenerateMSBuildEditorConfigFile;GenerateMSBuildEditorConfigFileCore">
    <PropertyGroup>
      <CsWinRTCcwLookupTableGeneratorEnabled Condition="'$(CsWinRTCcwLookupTableGeneratorEnabled)' == '' and
                                                        '$(CsWinRTComponent)' == 'true'">true</CsWinRTCcwLookupTableGeneratorEnabled>

      <!--
        Back-compat: first check whether 'CsWinRTIncludes' is set to a list of items.
        If so, this check will set 'CsWinRTHasAnyIncludes' to 'true', and we're done.
        We also check 'CsWinRTFilters' from here: setting either one is sufficient.
      -->
      <CsWinRTHasAnyIncludes>false</CsWinRTHasAnyIncludes>
      <CsWinRTHasAnyIncludes Condition="'@(CsWinRTIncludes)' != '' or $(CsWinRTFilters.Contains('-include'))">true</CsWinRTHasAnyIncludes>
      
      <!--
        If 'CsWinRTHasAnyIncludes' is 'false', but 'CsWinRTIncludes' is not actually empty, treat it as
        a 'string', and also account for people formatting it over multiple lines in the .csproj files.
        That is, we trim it and remove all newline characters, and then check whether the result is not
        empty. If not, then we do have some WinRT includes.
        
        This handles eg. Win2D setting this property like so:
        
        '''
        <CSWinRTIncludes>
          Microsoft.Graphics.Canvas;
        </CSWinRTIncludes>
        '''
      -->
      <CsWinRTIncludesWithFixup Condition="'$(CsWinRTHasAnyIncludes)' == 'false'">$(CSWinRTIncludes)</CsWinRTIncludesWithFixup>
      <CsWinRTIncludesWithFixup Condition="'$(CsWinRTHasAnyIncludes)' == 'false'">$(CsWinRTIncludesWithFixup.Trim())</CsWinRTIncludesWithFixup>
      <CsWinRTIncludesWithFixup Condition="'$(CsWinRTHasAnyIncludes)' == 'false'">$([System.Text.RegularExpressions.Regex]::Replace($(CsWinRTIncludesWithFixup), '[\r\n]', ''))</CsWinRTIncludesWithFixup>
      <CsWinRTHasAnyIncludes Condition="'$(CsWinRTIncludesWithFixup)' != ''">true</CsWinRTHasAnyIncludes>

      <!--
        If the lookup generator is enabled, the AOT source generator generates vtable entries for generic types and boxing scenarios that it detects.
        This is not intended to be ran on projections, so we try to detect that and disable it if a projection is being generated.
      -->
      <CsWinRTCcwLookupTableGeneratorEnabled Condition="'$(CsWinRTCcwLookupTableGeneratorEnabled)' == '' and
                                                        '$(CsWinRTGenerateProjection)' == 'true' and
                                                        '$(OutputType)' == 'Library' and
                                                        '$(CsWinRTHasAnyIncludes)' == 'true'">false</CsWinRTCcwLookupTableGeneratorEnabled>
      <CsWinRTCcwLookupTableGeneratorEnabled Condition="'$(CsWinRTCcwLookupTableGeneratorEnabled)' == ''">true</CsWinRTCcwLookupTableGeneratorEnabled>

      <!--
        CsWinRTAotWarningLevel decides the level of warning from the AOT analyzer.
            0: No warnings
           *1: Warnings for scenarios involving WinRT types that are not built-in system types mapped to WinRT.
            2: Level 1 warnings and warnings for scenarios involving built-in system types mapped to WinRT.
        This is not intended to be ran on projections, so we try to detect that and disable it if a projection is being generated.
        Level 1 is currently the default to avoid noise from built-in system types that might not be used in WinRT scenarios
        but level 2 should be enabled and the warnings from it should be evaluated to ensure AOT and trimming compatibility.
        Level 2 might be made the default in the future.
      -->		
      <CsWinRTAotWarningLevel Condition="'$(CsWinRTAotWarningLevel)' == '' and
                                                        '$(CsWinRTGenerateProjection)' == 'true' and
                                                        '$(OutputType)' == 'Library' and
                                                        '$(CsWinRTHasAnyIncludes)' == 'true'">0</CsWinRTAotWarningLevel>
      <CsWinRTAotWarningLevel Condition="'$(CsWinRTAotWarningLevel)' == ''">1</CsWinRTAotWarningLevel>
    </PropertyGroup>
  </Target>

  <!-- Remove WinRT.Host.dll and WinRT.Host.Shim.dll references -->
  <Target Name="CsWinRTRemoveHostingDllReferences" AfterTargets="ResolvePackageAssets" BeforeTargets="ResolveLockFileAnalyzers" Outputs="@(Reference)">
    <PropertyGroup>
      <CsWinRTPkg-Net8Dir>$(CsWinRTPath)lib\net8.0</CsWinRTPkg-Net8Dir>
      <CsWinRTPkg-NativeDir>$(CsWinRTPath)runtimes\**\native</CsWinRTPkg-NativeDir>
    </PropertyGroup>
    <ItemGroup>
     <ReferenceCopyLocalPaths        Remove="$(CsWinRTPkg-NativeDir)\WinRT.Host.dll"/>
     <RuntimeCopyLocalItems          Remove="$(CsWinRTPkg-NativeDir)\WinRT.Host.dll"/>
     <RuntimeTargetsCopyLocalItems   Remove="$(CsWinRTPkg-NativeDir)\WinRT.Host.dll"/>
     <Reference                      Remove="$(CsWinRTPkg-Net8Dir)\WinRT.Host.Shim.dll"/>
     <ResolvedCompileFileDefinitions Remove="$(CsWinRTPkg-Net8Dir)\WinRT.Host.Shim.dll"/>
     <RuntimeCopyLocalItems          Remove="$(CsWinRTPkg-Net8Dir)\WinRT.Host.Shim.dll"/>
    </ItemGroup>
  </Target>

  <!-- Remove Windows.Winmd reference to prevent compile collisions-->
  <Target Name="CsWinRTRemoveWindowsReference" Outputs="@(Reference)" Condition="$(CsWinRTEnabled)">
   <ItemGroup>
     <Reference Remove="Windows"/>
   </ItemGroup>
  </Target>

  <Target Name="CsWinRTRemoveWinMDReferences" BeforeTargets="BeforeCompile" AfterTargets="ResolveReferences">
    <ItemGroup>
      <!--Move winmd references into private item group to prevent subsequent winmd reference errors-->
      <CsWinRTRemovedReferences Include="@(ReferencePath)" Condition="'%(ReferencePath.Extension)' == '.winmd'" />
      <CsWinRTInputs Include="@(CsWinRTRemovedReferences)"/>

      <!--Prevent NETSDK1130 errors from winmd references-->
      <ReferencePath Remove="@(ReferencePath)" Condition="'%(ReferencePath.Extension)' == '.winmd'" />
      <ReferencePathWithRefAssemblies Remove="@(CsWinRTRemovedReferences)" 
        Condition="'%(CsWinRTRemovedReferences.Filename)%(CsWinRTRemovedReferences.Extension)' == '%(ReferencePathWithRefAssemblies.Filename)%(ReferencePathWithRefAssemblies.Extension)'" />
      <!--Do not publish projection source winmds, but do include implementation dlls -->
      <ReferenceCopyLocalPaths Remove="@(CsWinRTRemovedReferences)" />
      <ReferenceCopyLocalPaths Include="@(CsWinRTRemovedReferences->'%(RootDir)%(Directory)%(DestinationSubDirectory)%(Implementation)')" 
                               Condition="'%(CsWinRTRemovedReferences.Implementation)' != '' AND Exists('%(CsWinRTRemovedReferences.RootDir)%(CsWinRTRemovedReferences.Directory)%(CsWinRTRemovedReferences.DestinationSubDirectory)%(CsWinRTRemovedReferences.Implementation)')" />
      <!--Remove winmd references from deps.json to prevent CLR failing unit test execution-->
      <ReferenceDependencyPaths Remove="@(ReferenceDependencyPaths)" Condition="%(ReferenceDependencyPaths.Extension) == '.winmd'"/>
    </ItemGroup>
  </Target>

  <Target Name="CsWinRTPrepareProjection" DependsOnTargets="$(CsWinRTPrepareProjectionDependsOn)" Outputs="$(CsWinRTGeneratedFilesDir)">
    <PropertyGroup>
      <CsWinRTGeneratedFilesDir Condition="'$(CsWinRTGeneratedFilesDir)' == '' and '$(GeneratedFilesDir)' != ''">$(GeneratedFilesDir)\CsWinRT\</CsWinRTGeneratedFilesDir>
      <CsWinRTGeneratedFilesDir Condition="'$(CsWinRTGeneratedFilesDir)' == ''">$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', 'Generated Files', 'CsWinRT'))</CsWinRTGeneratedFilesDir>
    </PropertyGroup>
  </Target>

  <Target Name="CsWinRTCleanGenerateProjectionOutputs">
    <Delete Files="$(CsWinRTGeneratedFilesDir)cswinrt.rsp" />
    <Delete Files="$(CsWinRTGeneratedFilesDir)cswinrt_internal.rsp" />
  </Target>

  <Target Name="CsWinRTGenerateProjection"
          DependsOnTargets="CsWinRTPrepareProjection;CsWinRTRemoveWinMDReferences"
          Condition="'$(CsWinRTGenerateProjection)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(CsWinRTInputs);$(CsWinRTExe)"
          Outputs="$(CsWinRTGeneratedFilesDir)cswinrt.rsp">

    <PropertyGroup>
      <CsWinRTResponseFile>$(CsWinRTGeneratedFilesDir)cswinrt.rsp</CsWinRTResponseFile>
      <CsWinRTResponseFilePrivateProjection>$(CsWinRTGeneratedFilesDir)cswinrt_internal.rsp</CsWinRTResponseFilePrivateProjection>
      <!-- %40 is an MSBuild escape code for the @ character; 
       https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/msbuild-special-characters?view=vs-2015&redirectedfrom=MSDN 
  -->
      <CsWinRTCommand>"$(CsWinRTExe)" %40"$(CsWinRTResponseFile)"</CsWinRTCommand>
      <CsWinRTCommandPrivateProjection>"$(CsWinRTExe)" %40"$(CsWinRTResponseFilePrivateProjection)"</CsWinRTCommandPrivateProjection>
      <CsWinRTWindowsMetadataInput Condition="'$(CsWinRTWindowsMetadata)' != ''">-input $(CsWinRTWindowsMetadata)</CsWinRTWindowsMetadataInput>
    </PropertyGroup>

    <ItemGroup>
      <CsWinRTDetectWindowsMetadata Include="@(CsWinRTInputs)" Condition="'%(CsWinRTInputs.Filename)%(CsWinRTInputs.Extension)' == 'Windows.Foundation.FoundationContract.winmd'"></CsWinRTDetectWindowsMetadata>
      <CsWinRTDetectWindowsMetadata Include="@(CsWinRTInputs)" Condition="'%(CsWinRTInputs.Filename)%(CsWinRTInputs.Extension)' == 'Windows.winmd'"></CsWinRTDetectWindowsMetadata>
    </ItemGroup>

    <Error Condition="'$(CsWinRTParams)$(CsWinRTFilters)$(CsWinRTWindowsMetadata)@(CsWinRTDetectWindowsMetadata)' == ''"
      Text="Windows Metadata not provided or detected.  See https://github.com/microsoft/CsWinRT/tree/master/nuget/readme.md" />

    <PropertyGroup>
      <CsWinRTExcludes Condition="'$(CsWinRTExcludes)' == ''">Windows;Microsoft</CsWinRTExcludes>
      <CsWinRTExcludesPrivate Condition="'$(CsWinRTExcludesPrivate)' == ''">Windows;Microsoft</CsWinRTExcludesPrivate>
    </PropertyGroup>

    <!-- Inputs set by users -->
    <ItemGroup>
      <CsWinRTExcludePrivateItems Include="$(CsWinRTExcludesPrivate)"/>
      <CsWinRTIncludePrivateItems Include="$(CsWinRTIncludesPrivate)"/>
    </ItemGroup>

    <ItemGroup>
      <CsWinRTExcludeItems Include="$(CsWinRTExcludes)"/>
      <CsWinRTIncludeItems Include="$(CsWinRTIncludes)"/>
    </ItemGroup>

    <PropertyGroup>
      <CsWinRTPrivateFilters Condition="'$(CsWinRTPrivateFilters)' == ''">
@(CsWinRTExcludePrivateItems->'-exclude %(Identity)', '&#x0d;&#x0a;')
@(CsWinRTIncludePrivateItems->'-include %(Identity)', '&#x0d;&#x0a;')
      </CsWinRTPrivateFilters>

      <CsWinRTFilters Condition="'$(CsWinRTFilters)' == ''">
@(CsWinRTExcludeItems->'-exclude %(Identity)', '&#x0d;&#x0a;')
@(CsWinRTIncludeItems->'-include %(Identity)', '&#x0d;&#x0a;')
      </CsWinRTFilters>

      <CsWinRTInteropMetadata Condition="'$(CsWinRTInteropMetadata)' == ''">$([MSBuild]::NormalizePath('$(MSBuildThisFileDirectory)', '..\metadata\WinRT.Interop.winmd'))</CsWinRTInteropMetadata>
      <CsWinRTIncludeWinRTInterop Condition="$(CsWinRTFilters.Contains('-include Windows&#x0d;&#x0a;')) or $(CsWinRTFilters.Contains('-include Windows&#x0a;'))">
-input $(CsWinRTInteropMetadata)
-include WinRT.Interop
      </CsWinRTIncludeWinRTInterop>


      <CsWinRTPrivateIncludeWinRTInterop Condition="$(CsWinRTPrivateFilters.Contains('-include Windows&#x0d;&#x0a;')) or $(CsWinRTPrivateFilters.Contains('-include Windows&#x0a;'))">
-input $(CsWinRTInteropMetadata)
-include WinRT.Interop
      </CsWinRTPrivateIncludeWinRTInterop>

      <CsWinRTInternalProjection Condition="'$(CsWinRTPrivateProjection)' == 'true'">-internal</CsWinRTInternalProjection>
      <CsWinRTEmbeddedProjection Condition="'$(CsWinRTEmbedded)' == 'true'">-embedded</CsWinRTEmbeddedProjection>
      <CsWinRTEmbeddedEnums Condition="'$(CsWinRTEmbeddedPublicEnums)' == 'true'">-public_enums</CsWinRTEmbeddedEnums>
      <CsWinRTPublicExclusiveTo Condition="'$(CsWinRTPublicExclusiveToInterfaces)' == 'true'">-public_exclusiveto</CsWinRTPublicExclusiveTo>
      <CsWinRTDynamicallyInterfaceCastableExclusiveTo Condition="'$(CsWinRTDynamicallyInterfaceCastableExclusiveTo)' == 'true'">-idic_exclusiveto</CsWinRTDynamicallyInterfaceCastableExclusiveTo>

      <CsWinRTParams Condition="'$(CsWinRTParams)' == ''">
$(CsWinRTCommandVerbosity)
-target $(CsWinRTExeTFM)
$(CsWinRTWindowsMetadataInput)
-input @(CsWinRTInputs->'"%(FullPath)"', ' ')
-output "$(CsWinRTGeneratedFilesDir.TrimEnd('\'))"
$(CsWinRTFilters)
$(CsWinRTIncludeWinRTInterop)
$(CsWinRTEmbeddedProjection)
$(CsWinRTEmbeddedEnums)
$(CsWinRTPublicExclusiveTo)
$(CsWinRTDynamicallyInterfaceCastableExclusiveTo)
      </CsWinRTParams>

      <CsWinRTPrivateParams Condition="'$(CsWinRTPrivateParams)' == ''">
$(CsWinRTCommandVerbosity)
-target $(CsWinRTExeTFM)
$(CsWinRTWindowsMetadataInput)
-input @(CsWinRTInputs->'"%(FullPath)"', ' ')
-output "$(CsWinRTGeneratedFilesDir.TrimEnd('\'))"
$(CsWinRTPrivateFilters)
$(CsWinRTPrivateIncludeWinRTInterop)
$(CsWinRTInternalProjection)
      </CsWinRTPrivateParams>
    </PropertyGroup>

    <!-- 
      During a design-time build, generation of the CsWinRT projection might fail (e.g. input .winmds might
      not exist if a full build hasn't completed yet). To avoid causing a design-time build break, which can 
      put the design-time build results of dependent projects into a bad state, we want the build to continue
      if cswinrt.exe encounters an error during a design-time build.
    -->
    <PropertyGroup>
      <CsWinRTContinueOnError>false</CsWinRTContinueOnError>
      <CsWinRTContinueOnError Condition="'$(DesignTimeBuild)' == 'true' OR '$(BuildingProject)' != 'true'">true</CsWinRTContinueOnError>
    </PropertyGroup>

    <ItemGroup>
      <CsWinRTFilesToDelete Include="$(CsWinRTGeneratedFilesDir)*.cs"/>
    </ItemGroup>
    <Delete Files="@(CsWinRTFilesToDelete)" />
    <MakeDir Directories="$(CsWinRTGeneratedFilesDir)" />
    <WriteLinesToFile File="$(CsWinRTResponseFile)" Lines="$(CsWinRTParams)" Overwrite="true" />
    <WriteLinesToFile File="$(CsWinRTResponseFilePrivateProjection)" Lines="$(CsWinRTPrivateParams)" Overwrite="true" />
    <Message Text="$(CsWinRTCommand)" Importance="$(CsWinRTMessageImportance)" />
    <Exec Command="$(CsWinRTCommand)" ContinueOnError="$(CsWinRTContinueOnError)" />

    <Message Text="$(CsWinRTCommandPrivateProjection)" Importance="$(CsWinRTMessageImportance)" />
    <Exec Command="$(CsWinRTCommandPrivateProjection)" ContinueOnError="$(CsWinRTContinueOnError)" Condition="'$(CsWinRTPrivateProjection)' == 'true'"/>

    <ItemGroup Condition="'$(CsWinRTComponent)' != 'true' and Exists('$(CsWinRTResponseFile)')">
      <UpToDateCheckInput Include="@(CsWinRTInputs)" Set="WinMDs" />
      <UpToDateCheckInput Include="$(CsWinRTExe)" Set="WinMDs" />
      <UpToDateCheckBuilt Include="$(CsWinRTResponseFile)" Set="WinMDs" />
    </ItemGroup>

    <!-- Clean the output file if the target failed to indicate it needs to be rebuild -->
    <OnError ExecuteTargets="CsWinRTCleanGenerateProjectionOutputs" />
  </Target>

  <!-- Note: GenerateTargetFrameworkMonikerAttribute is conditional upon @(Compile) not being empty -->
  <Target Name="CsWinRTIncludeProjection" BeforeTargets="BeforeCompile;GenerateTargetFrameworkMonikerAttribute" DependsOnTargets="CsWinRTGenerateProjection" Condition="$(CsWinRTEnabled)">
    <ItemGroup>
      <Compile Include="$(CsWinRTGeneratedFilesDir)*.cs" Exclude="@(Compile)" />
    </ItemGroup>
  </Target>

  <!-- Emit a warning when 'CsWinRTMergeReferencedActivationFactories' is used incorrectly -->
  <Target
    Name="_CsWinRTErrorForInvalidMergeReferencedActivationFactories"
    BeforeTargets="BeforeCompile"
    Condition="'$(CsWinRTMergeReferencedActivationFactories)' == 'true' AND '$(PublishAot)' != 'true'">
    <Error Text="The 'CsWinRTMergeReferencedActivationFactories' property can only be set when publishing with Native AOT. Make sure to set the 'PublishAot' property to 'true'." />
  </Target>

  <!-- Produces a stub .exe for the application, if requested -->
  <Target
    Name="_CsWinRTGenerateStubExe"
    AfterTargets="Publish"
    Condition="'$(_CsWinRTEnableStubExeGeneration)' == 'true'">
    <PropertyGroup>
    
      <!-- Prepare the generated files directory -->
      <_StubExeFolderName>StubExe</_StubExeFolderName>
      <_StubExeGeneratedFilesDir Condition="'$(_StubExeGeneratedFilesDir)' == '' AND '$(GeneratedFilesDir)' != ''">$(GeneratedFilesDir)\$(_StubExeFolderName)\</_StubExeGeneratedFilesDir>
      <_StubExeGeneratedFilesDir Condition="'$(_StubExeGeneratedFilesDir)' == ''">$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', 'Generated Files', '$(_StubExeFolderName)'))</_StubExeGeneratedFilesDir>
    
      <!-- The path of the .lib file produced by the Native AOT toolchain, which we need for the linker -->
      <_StubExeNativeLibraryPath>$([System.IO.Path]::Combine($(MSBuildProjectDirectory), $(NativeOutputPath), $(AssemblyName).lib))</_StubExeNativeLibraryPath>
    
      <!-- Prepare the path of the .c file with the stub .exe source we need to compile -->
      <_StubExeSourceFileName>$(AssemblyName).c</_StubExeSourceFileName>
      <_StubExeSourceFilePath>$([System.IO.Path]::Combine($(_StubExeGeneratedFilesDir), $(_StubExeSourceFileName)))</_StubExeSourceFilePath>
    
      <!-- Prepare the output path of the resulting stub .exe -->
      <_StubExeBinaryFileName>$(AssemblyName).exe</_StubExeBinaryFileName>
      <_StubExeBinaryOutputFilePath>$([System.IO.Path]::Combine($(_StubExeGeneratedFilesDir), $(_StubExeBinaryFileName)))</_StubExeBinaryOutputFilePath>
      <_StubExeBinaryDestinationFilePath>$([System.IO.Path]::Combine($(MSBuildProjectDirectory), $(PublishDir), $(_StubExeBinaryFileName)))</_StubExeBinaryDestinationFilePath>
    </PropertyGroup>
    
    <!--
      This is a simple C source file just jumping into the special 'Main' program of the current project.
      Note that we need to use '%3B' to escape the semicolons, as otherwise it'll be skipped entirely.
    -->
    <PropertyGroup>
      <_StubExeSourceFileLines>
        <![CDATA[#include <wchar.h>

// Declare the import for '__managed__Main', which is a special export produced by the
// Native AOT runtime to allow jumping into the real 'Main' of an application. This is
// exported automatically when the 'CustomNativeMain' property is set to 'true'.
__declspec(dllimport)
int __stdcall __managed__Main(int argc, wchar_t** argv)%3B

// Our entry point is simply a direct jump into the entry point from Native AOT
int wmain(int argc, wchar_t** argv)
{
    return __managed__Main(argc, argv)%3B
}]]>
      </_StubExeSourceFileLines>
    </PropertyGroup>
    
    <!-- This whole target might take a minute (and it might fail), so notify the user to help debug issues -->
    <Message Text="Generating stub .exe" />

    <!-- Ensure the folder exists, or writing to the source file will fail -->
    <MakeDir Directories="$(_StubExeGeneratedFilesDir)"/>
      
    <!-- Write the stub .exe source -->
    <WriteLinesToFile Lines="$(_StubExeSourceFileLines)" Overwrite="true" WriteOnlyWhenDifferent="true" File="$(_StubExeSourceFilePath)" />

    <!--
      We want to invoke MSVC in the folder where we also want the .exe to be produced in.
      So we also need to adjust the input paths to be relative to that working directory.
    -->
    <PropertyGroup>
      <_StubExeSourceFilePathRelative>$([MSBuild]::MakeRelative($(_StubExeGeneratedFilesDir), $(_StubExeSourceFilePath)))</_StubExeSourceFilePathRelative>
      <_StubExeNativeLibraryPathRelative>$([MSBuild]::MakeRelative($(_StubExeGeneratedFilesDir), $(_StubExeNativeLibraryPath)))</_StubExeNativeLibraryPathRelative>
    </PropertyGroup>

    <!--
      Get the path of 'cl.exe' from the Native AOT tooling, which finds the install folder for MSVC already.
      By doing this, we make sure that this can work from a normal terminal too, not just a VS Developer cmd.
    -->
    <PropertyGroup>
      <_ClExeFilePath Condition="'$(_ClExeFilePath)' == '' AND '$(_CppToolsDirectory)' != ''">$([System.IO.Path]::Combine($(_CppToolsDirectory), 'cl.exe'))</_ClExeFilePath>
      <_ClExeFilePath Condition="'$(_ClExeFilePath)' == ''">cl</_ClExeFilePath>
    </PropertyGroup>

    <!-- Prepare the arguments for MSVC -->
    <PropertyGroup>

      <!-- Hide the copyright banner, to reduce visual clutter (https://learn.microsoft.com/cpp/build/reference/nologo-suppress-startup-banner-c-cpp) -->
      <_StubExeMsvcArgs>$(_StubExeMsvcArgs) /nologo</_StubExeMsvcArgs>

      <!-- Optimize for speed (https://learn.microsoft.com/cpp/build/reference/o1-o2-minimize-size-maximize-speed) -->
      <_StubExeMsvcArgs>$(_StubExeMsvcArgs) /O2</_StubExeMsvcArgs>

      <!--
        Remove some buffer overrun validation code that requires additional CRT support. This is not needed for the stub .exe,
        as we are literally only jumping into the custom entry point of the app (which will have its own buffer overrun checks)
        (https://learn.microsoft.com/cpp/build/reference/gs-buffer-security-check).
      -->
      <_StubExeMsvcArgs>$(_StubExeMsvcArgs) /GS-</_StubExeMsvcArgs>

      <!-- Denote the start of the sequence of linker options (https://learn.microsoft.com/cpp/build/reference/compiler-command-line-syntax) -->
      <_StubExeMsvcArgs>$(_StubExeMsvcArgs) /link</_StubExeMsvcArgs>

      <!-- Skip the relocation section, as it's not needed for .exe files (https://learn.microsoft.com/cpp/build/reference/fixed-fixed-base-address) -->
      <_StubExeMsvcArgs>$(_StubExeMsvcArgs) /fixed</_StubExeMsvcArgs>

      <!-- Skip generating additional code for incremental linking (https://learn.microsoft.com/cpp/build/reference/incremental-link-incrementally) -->
      <_StubExeMsvcArgs>$(_StubExeMsvcArgs) /incremental:no</_StubExeMsvcArgs>

      <!-- Enable COMDAT folding and remove unreferenced code (https://learn.microsoft.com/cpp/build/reference/opt-optimizations) -->
      <_StubExeMsvcArgs>$(_StubExeMsvcArgs) /opt:icf</_StubExeMsvcArgs>
      <_StubExeMsvcArgs>$(_StubExeMsvcArgs) /opt:ref</_StubExeMsvcArgs>
    </PropertyGroup>
    
    <!--
      Remove the broken .exe, if present (see https://github.com/dotnet/runtime/issues/111313). We want to do this before
      compiling the binary, to ensure users won't ever see the wrong one in the publish folder and use that by accident.
    -->
    <Delete Files="$(_StubExeBinaryDestinationFilePath)" />
    
    <!-- Invoke MSVC to produce the native executable -->
    <Exec
      Command='"$(_ClExeFilePath)" "$(_StubExeSourceFilePathRelative)" "$(_StubExeNativeLibraryPathRelative)" $(_StubExeMsvcArgs)'
      ConsoleToMsBuild="true"
      WorkingDirectory="$(_StubExeGeneratedFilesDir)" />
    
    <!-- Copy the resulting executable to the publish directory -->
    <Copy SourceFiles="$(_StubExeBinaryOutputFilePath)" DestinationFiles="$(_StubExeBinaryDestinationFilePath)" />
  </Target>

  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.Prerelease.targets" Condition="Exists('$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.Prerelease.targets')"/>
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.Authoring.targets" Condition="'$(CsWinRTComponent)' == 'true'"/>
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.IIDOptimizer.targets" Condition="'$(CsWinRTIIDOptimizerOptOut)' != 'true'"/>

  <!-- Default values for all custom CsWinRT runtime feature switches -->
  <PropertyGroup>
    <CsWinRTEnableDynamicObjectsSupport Condition="'$(CsWinRTEnableDynamicObjectsSupport)' == ''">true</CsWinRTEnableDynamicObjectsSupport>
    <CsWinRTUseExceptionResourceKeys Condition="'$(CsWinRTUseExceptionResourceKeys)' == ''">false</CsWinRTUseExceptionResourceKeys>
    <CsWinRTEnableDefaultCustomTypeMappings Condition="'$(CsWinRTEnableDefaultCustomTypeMappings)' == ''">true</CsWinRTEnableDefaultCustomTypeMappings>
    <CsWinRTEnableICustomPropertyProviderSupport Condition="'$(CsWinRTEnableICustomPropertyProviderSupport)' == ''">true</CsWinRTEnableICustomPropertyProviderSupport>
    <CsWinRTEnableIReferenceSupport Condition="'$(CsWinRTEnableIReferenceSupport)' == ''">true</CsWinRTEnableIReferenceSupport>
    <CsWinRTEnableIDynamicInterfaceCastableSupport Condition="'$(CsWinRTEnableIDynamicInterfaceCastableSupport)' == ''">true</CsWinRTEnableIDynamicInterfaceCastableSupport>
    <CsWinRTEnableManifestFreeActivation Condition="'$(CsWinRTEnableManifestFreeActivation)' == ''">true</CsWinRTEnableManifestFreeActivation>
    <CsWinRTManifestFreeActivationReportOriginalException Condition="'$(CsWinRTManifestFreeActivationReportOriginalException)' == ''">false</CsWinRTManifestFreeActivationReportOriginalException>

    <!--
      Note: the 'CsWinRTUseWindowsUIXamlProjections' property and associated 'CSWINRT_USE_WINDOWS_UI_XAML_PROJECTIONS' feature
      switch are set by the .NET SDK, so that the right projection mode is enabled even when CsWinRT is not directly referenced.
    -->
  </PropertyGroup>

  <!--
    Configuration for the feature switches (to support IL trimming).
    See the 'ILLink.Substitutions.xml' file for more details on that.
  -->
  <ItemGroup>

    <!-- CSWINRT_ENABLE_DYNAMIC_OBJECTS_SUPPORT switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_DYNAMIC_OBJECTS_SUPPORT"
                                    Value="$(CsWinRTEnableDynamicObjectsSupport)"
                                    Trim="true" />

    <!-- CSWINRT_USE_EXCEPTION_RESOURCE_KEYS switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_USE_EXCEPTION_RESOURCE_KEYS"
                                    Value="$(CsWinRTUseExceptionResourceKeys)"
                                    Trim="true" />
                                  
    <!-- CSWINRT_ENABLE_DEFAULT_CUSTOM_TYPE_MAPPINGS switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_DEFAULT_CUSTOM_TYPE_MAPPINGS"
                                    Value="$(CsWinRTEnableDefaultCustomTypeMappings)"
                                    Trim="true" />

    <!-- CSWINRT_ENABLE_ICUSTOMPROPERTYPROVIDER_SUPPORT switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_ICUSTOMPROPERTYPROVIDER_SUPPORT"
                                    Value="$(CsWinRTEnableICustomPropertyProviderSupport)"
                                    Trim="true" />
    
    <!-- CSWINRT_ENABLE_IREFERENCE_SUPPORT switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_IREFERENCE_SUPPORT"
                                    Value="$(CsWinRTEnableIReferenceSupport)"
                                    Trim="true" />

    <!-- CSWINRT_ENABLE_IDYNAMICINTERFACECASTABLE switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_IDYNAMICINTERFACECASTABLE"
                                    Value="$(CsWinRTEnableIDynamicInterfaceCastableSupport)"
                                    Trim="true" />

    <!-- CSWINRT_ENABLE_MANIFEST_FREE_ACTIVATION switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_MANIFEST_FREE_ACTIVATION"
                                    Value="$(CsWinRTEnableManifestFreeActivation)"
                                    Trim="true" />

    <!-- CSWINRT_MANIFEST_FREE_ACTIVATION_REPORT_ORIGINAL_EXCEPTION switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_MANIFEST_FREE_ACTIVATION_REPORT_ORIGINAL_EXCEPTION"
                                    Value="$(CsWinRTManifestFreeActivationReportOriginalException)"
                                    Trim="true" />
  </ItemGroup>

</Project>
