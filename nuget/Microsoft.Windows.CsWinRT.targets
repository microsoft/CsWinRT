<!--
***********************************************************************************************
Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>
    <CsWinRTMessageImportance Condition="'$(CsWinRTMessageImportance)' == ''">normal</CsWinRTMessageImportance>
    <CsWinRTCommandVerbosity Condition="'$(CsWinRTMessageImportance)' == 'high'">-verbose</CsWinRTCommandVerbosity>
    <ResolveAssemblyReferencesDependsOn Condition="'$(CsWinRTRemoveWindowsReference)'!='false'">$(ResolveAssemblyReferencesDependsOn);CsWinRTRemoveWindowsReference</ResolveAssemblyReferencesDependsOn>
    <CsWinRTEnabled Condition="'$(CsWinRTEnabled)' == ''">true</CsWinRTEnabled>
    <CsWinRTEnabled Condition="'$(CsWinRTEnabled)' != 'true'">false</CsWinRTEnabled>
    <CsWinRTGenerateProjection Condition="!$(CsWinRTEnabled)">false</CsWinRTGenerateProjection>
    <CsWinRTGenerateProjection Condition="'$(CsWinRTGenerateProjection)' == ''">true</CsWinRTGenerateProjection>
    <AllowUnsafeBlocks Condition="$(CsWinRTEnabled)">true</AllowUnsafeBlocks>

    <!--
      Making sure ResolveAssemblyReferences runs before CoreCompile runs as we have seen it not run
      in WPF scenarios causing for our targeting pack to not get included or conflicts to be resolved.
    -->
    <CoreCompileDependsOn>ResolveAssemblyReferences;CsWinRTIncludeProjection;CsWinRTRemoveWinMDReferences;$(CoreCompileDependsOn)</CoreCompileDependsOn>
    <TrackFileAccess Condition="'$(CsWinRTComponent)' != 'true'">false</TrackFileAccess>
    <CsWinRTAotOptimizerEnabled Condition="'$(CsWinRTAotOptimizerEnabled)' == '' and $([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) >= 6">true</CsWinRTAotOptimizerEnabled>

    <!--
      If the AOT optimizer is enabled, and we're publishing with NativeAOT, automatically set CsWinRTAotExportsEnabled as well.
      Only do this if the property is not already set by the user, so we respect any existing preference.
    -->
    <CsWinRTAotExportsEnabled Condition="'$(CsWinRTAotExportsEnabled)' == '' and '$(CsWinRTAotOptimizerEnabled)' == 'true' and '$(PublishAot)' == 'true'">true</CsWinRTAotExportsEnabled>
    <CsWinRTAotExportsEnabled Condition="'$(CsWinRTAotExportsEnabled)' != 'true'">false</CsWinRTAotExportsEnabled>

    <!-- Set the RCW factory fallback generator to not be opt-in by default -->
    <CsWinRTRcwFactoryFallbackGeneratorForceOptIn Condition="'$(CsWinRTRcwFactoryFallbackGeneratorForceOptIn)' != 'true'">false</CsWinRTRcwFactoryFallbackGeneratorForceOptIn>
    <CsWinRTRcwFactoryFallbackGeneratorForceOptOut Condition="'$(CsWinRTRcwFactoryFallbackGeneratorForceOptOut)' != 'true'">false</CsWinRTRcwFactoryFallbackGeneratorForceOptOut>

    <!--
      These properties are defined in this property group and not in the 'CsWinRTGenerateProjection'
      target, because they are also needed in authoring scenarios (which will not run that target).
    -->
    <CsWinRTExeTFM Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 5">net5.0</CsWinRTExeTFM>
    <CsWinRTExeTFM Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 6">net6.0</CsWinRTExeTFM>
    <CsWinRTExeTFM Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 7">net7.0</CsWinRTExeTFM>
    <CsWinRTExeTFM Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) >= 8">net8.0</CsWinRTExeTFM>
    <CsWinRTExeTFM Condition="'$(CsWinRTExeTFM)' == ''">netstandard2.0</CsWinRTExeTFM>
    <CsWinRTWindowsMetadata Condition="'$(CsWinRTWindowsMetadata)' == ''">$(WindowsSDKVersion.TrimEnd('\'))</CsWinRTWindowsMetadata>
    <CsWinRTWindowsMetadata Condition="'$(CsWinRTWindowsMetadata)' == ''">$(TargetPlatformVersion)</CsWinRTWindowsMetadata>

    <!-- Default to not using the environment tools -->
    <CsWinRTUseEnvironmentalTools Condition="'$(CsWinRTUseEnvironmentalTools)' == ''">false</CsWinRTUseEnvironmentalTools>
  </PropertyGroup>

  <ItemGroup>
    <CompilerVisibleProperty Include="CsWinRTAotOptimizerEnabled" />
    <CompilerVisibleProperty Include="CsWinRTAotExportsEnabled" />
    <CompilerVisibleProperty Include="CsWinRTRcwFactoryFallbackGeneratorForceOptIn" />
    <CompilerVisibleProperty Include="CsWinRTRcwFactoryFallbackGeneratorForceOptOut" />
    <CompilerVisibleProperty Include="CsWinRTCcwLookupTableGeneratorEnabled" />
    <CompilerVisibleProperty Include="CsWinRTMergeReferencedActivationFactories" />
    <CompilerVisibleProperty Include="CsWinRTAotWarningLevel" />
  </ItemGroup>

  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.Embedded.targets" Condition="'$(CsWinRTEmbedded)' == 'true'"/>
  
  <Target Name="CsWinRTNet5EOL" Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 5" BeforeTargets="CsWinRTPrepareProjection">
    <Error Text="Support for .NET 5 ended with C#/WinRT 2.0. For .NET 5 support, use C#/WinRT version 1.6.5. See https://github.com/microsoft/CsWinRT/discussions/1232" />
  </Target>

  <Target Name="CsWinRTNet6EOL" Condition="$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 6 or $([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)')) == 7" BeforeTargets="CsWinRTPrepareProjection">
    <Error Text="Support for .NET 6 and .NET 7 ended with C#/WinRT 2.2. For .NET 6 or .NET 7 support, use C#/WinRT version 2.2.x." />
  </Target>

  <!-- Note this runs before the msbuild editor config file is generated because that is what is used to pass properties to the source generator. -->
  <Target Name="CsWinRTSetGeneratorProperties" BeforeTargets="GenerateMSBuildEditorConfigFile;GenerateMSBuildEditorConfigFileCore">
    <PropertyGroup>
      <CsWinRTCcwLookupTableGeneratorEnabled Condition="'$(CsWinRTCcwLookupTableGeneratorEnabled)' == '' and
                                                        '$(CsWinRTComponent)' == 'true'">true</CsWinRTCcwLookupTableGeneratorEnabled>

      <!--
        Back-compat: first check whether 'CsWinRTIncludes' is set to a list of items.
        If so, this check will set 'CsWinRTHasAnyIncludes' to 'true', and we're done.
        We also check 'CsWinRTFilters' from here: setting either one is sufficient.
      -->
      <CsWinRTHasAnyIncludes>false</CsWinRTHasAnyIncludes>
      <CsWinRTHasAnyIncludes Condition="'@(CsWinRTIncludes)' != '' or $(CsWinRTFilters.Contains('-include'))">true</CsWinRTHasAnyIncludes>
      
      <!--
        If 'CsWinRTHasAnyIncludes' is 'false', but 'CsWinRTIncludes' is not actually empty, treat it as
        a 'string', and also account for people formatting it over multiple lines in the .csproj files.
        That is, we trim it and remove all newline characters, and then check whether the result is not
        empty. If not, then we do have some WinRT includes.
        
        This handles eg. Win2D setting this property like so:
        
        '''
        <CSWinRTIncludes>
          Microsoft.Graphics.Canvas;
        </CSWinRTIncludes>
        '''
      -->
      <CsWinRTIncludesWithFixup Condition="'$(CsWinRTHasAnyIncludes)' == 'false'">$(CSWinRTIncludes)</CsWinRTIncludesWithFixup>
      <CsWinRTIncludesWithFixup Condition="'$(CsWinRTHasAnyIncludes)' == 'false'">$(CsWinRTIncludesWithFixup.Trim())</CsWinRTIncludesWithFixup>
      <CsWinRTIncludesWithFixup Condition="'$(CsWinRTHasAnyIncludes)' == 'false'">$([System.Text.RegularExpressions.Regex]::Replace($(CsWinRTIncludesWithFixup), '[\r\n]', ''))</CsWinRTIncludesWithFixup>
      <CsWinRTHasAnyIncludes Condition="'$(CsWinRTIncludesWithFixup)' != ''">true</CsWinRTHasAnyIncludes>

      <!--
        If the lookup generator is enabled, the AOT source generator generates vtable entries for generic types and boxing scenarios that it detects.
        This is not intended to be ran on projections, so we try to detect that and disable it if a projection is being generated.
      -->
      <CsWinRTCcwLookupTableGeneratorEnabled Condition="'$(CsWinRTCcwLookupTableGeneratorEnabled)' == '' and
                                                        '$(CsWinRTGenerateProjection)' == 'true' and
                                                        '$(OutputType)' == 'Library' and
                                                        '$(CsWinRTHasAnyIncludes)' == 'true'">false</CsWinRTCcwLookupTableGeneratorEnabled>
      <CsWinRTCcwLookupTableGeneratorEnabled Condition="'$(CsWinRTCcwLookupTableGeneratorEnabled)' == ''">true</CsWinRTCcwLookupTableGeneratorEnabled>

      <!--
        CsWinRTAotWarningLevel decides the level of warning from the AOT analyzer.
            0: No warnings
           *1: Warnings for scenarios involving WinRT types that are not built-in system types mapped to WinRT.
            2: Level 1 warnings and warnings for scenarios involving built-in system types mapped to WinRT.
        This is not intended to be ran on projections, so we try to detect that and disable it if a projection is being generated.
        Level 1 is currently the default to avoid noise from built-in system types that might not be used in WinRT scenarios
        but level 2 should be enabled and the warnings from it should be evaluated to ensure AOT and trimming compatibility.
        Level 2 might be made the default in the future.
      -->		
      <CsWinRTAotWarningLevel Condition="'$(CsWinRTAotWarningLevel)' == '' and
                                                        '$(CsWinRTGenerateProjection)' == 'true' and
                                                        '$(OutputType)' == 'Library' and
                                                        '$(CsWinRTHasAnyIncludes)' == 'true'">0</CsWinRTAotWarningLevel>
      <CsWinRTAotWarningLevel Condition="'$(CsWinRTAotWarningLevel)' == ''">1</CsWinRTAotWarningLevel>
    </PropertyGroup>
  </Target>

  <!-- Remove WinRT.Host.dll and WinRT.Host.Shim.dll references -->
  <Target Name="CsWinRTRemoveHostingDllReferences" AfterTargets="ResolvePackageAssets" BeforeTargets="ResolveLockFileAnalyzers" Outputs="@(Reference)">
    <PropertyGroup>
      <CsWinRTPkg-Net8Dir>$(CsWinRTPath)lib\net8.0</CsWinRTPkg-Net8Dir>
      <CsWinRTPkg-NativeDir>$(CsWinRTPath)runtimes\**\native</CsWinRTPkg-NativeDir>
    </PropertyGroup>
    <ItemGroup>
     <ReferenceCopyLocalPaths        Remove="$(CsWinRTPkg-NativeDir)\WinRT.Host.dll"/>
     <RuntimeCopyLocalItems          Remove="$(CsWinRTPkg-NativeDir)\WinRT.Host.dll"/>
     <RuntimeTargetsCopyLocalItems   Remove="$(CsWinRTPkg-NativeDir)\WinRT.Host.dll"/>
     <Reference                      Remove="$(CsWinRTPkg-Net8Dir)\WinRT.Host.Shim.dll"/>
     <ResolvedCompileFileDefinitions Remove="$(CsWinRTPkg-Net8Dir)\WinRT.Host.Shim.dll"/>
     <RuntimeCopyLocalItems          Remove="$(CsWinRTPkg-Net8Dir)\WinRT.Host.Shim.dll"/>
    </ItemGroup>
  </Target>

  <!-- Remove Windows.Winmd reference to prevent compile collisions-->
  <Target Name="CsWinRTRemoveWindowsReference" Outputs="@(Reference)" Condition="$(CsWinRTEnabled)">
   <ItemGroup>
     <Reference Remove="Windows"/>
   </ItemGroup>
  </Target>

  <Target Name="CsWinRTRemoveWinMDReferences" BeforeTargets="BeforeCompile" AfterTargets="ResolveReferences">
    <ItemGroup>
      <!--Move winmd references into private item group to prevent subsequent winmd reference errors-->
      <CsWinRTRemovedReferences Include="@(ReferencePath)" Condition="'%(ReferencePath.Extension)' == '.winmd'" />
      <CsWinRTInputs Include="@(CsWinRTRemovedReferences)"/>

      <!--Prevent NETSDK1130 errors from winmd references-->
      <ReferencePath Remove="@(ReferencePath)" Condition="'%(ReferencePath.Extension)' == '.winmd'" />
      <ReferencePathWithRefAssemblies Remove="@(CsWinRTRemovedReferences)" 
        Condition="'%(CsWinRTRemovedReferences.Filename)%(CsWinRTRemovedReferences.Extension)' == '%(ReferencePathWithRefAssemblies.Filename)%(ReferencePathWithRefAssemblies.Extension)'" />
      <!--Do not publish projection source winmds, but do include implementation dlls -->
      <ReferenceCopyLocalPaths Remove="@(CsWinRTRemovedReferences)" />
      <ReferenceCopyLocalPaths Include="@(CsWinRTRemovedReferences->'%(RootDir)%(Directory)%(DestinationSubDirectory)%(Implementation)')" 
                               Condition="'%(CsWinRTRemovedReferences.Implementation)' != '' AND Exists('%(CsWinRTRemovedReferences.RootDir)%(CsWinRTRemovedReferences.Directory)%(CsWinRTRemovedReferences.DestinationSubDirectory)%(CsWinRTRemovedReferences.Implementation)')" />
      <!--Remove winmd references from deps.json to prevent CLR failing unit test execution-->
      <ReferenceDependencyPaths Remove="@(ReferenceDependencyPaths)" Condition="%(ReferenceDependencyPaths.Extension) == '.winmd'"/>
    </ItemGroup>
  </Target>

  <Target Name="CsWinRTPrepareProjection" DependsOnTargets="$(CsWinRTPrepareProjectionDependsOn)" Outputs="$(CsWinRTGeneratedFilesDir)">
    <PropertyGroup>
      <CsWinRTGeneratedFilesDir Condition="'$(CsWinRTGeneratedFilesDir)' == '' and '$(GeneratedFilesDir)' != ''">$(GeneratedFilesDir)\CsWinRT\</CsWinRTGeneratedFilesDir>
      <CsWinRTGeneratedFilesDir Condition="'$(CsWinRTGeneratedFilesDir)' == ''">$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', 'Generated Files', 'CsWinRT'))</CsWinRTGeneratedFilesDir>
    </PropertyGroup>
  </Target>

  <Target Name="CsWinRTCleanGenerateProjectionOutputs">
    <Delete Files="$(CsWinRTGeneratedFilesDir)cswinrt.rsp" />
    <Delete Files="$(CsWinRTGeneratedFilesDir)cswinrt_internal.rsp" />
  </Target>

  <Target Name="CsWinRTGenerateProjection"
          DependsOnTargets="CsWinRTPrepareProjection;CsWinRTRemoveWinMDReferences"
          Condition="'$(CsWinRTGenerateProjection)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(CsWinRTInputs);$(CsWinRTExe)"
          Outputs="$(CsWinRTGeneratedFilesDir)cswinrt.rsp">

    <PropertyGroup>
      <CsWinRTResponseFile>$(CsWinRTGeneratedFilesDir)cswinrt.rsp</CsWinRTResponseFile>
      <CsWinRTResponseFilePrivateProjection>$(CsWinRTGeneratedFilesDir)cswinrt_internal.rsp</CsWinRTResponseFilePrivateProjection>
      <!-- %40 is an MSBuild escape code for the @ character; 
       https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/msbuild/msbuild-special-characters?view=vs-2015&redirectedfrom=MSDN 
  -->
      <CsWinRTCommand>"$(CsWinRTExe)" %40"$(CsWinRTResponseFile)"</CsWinRTCommand>
      <CsWinRTCommandPrivateProjection>"$(CsWinRTExe)" %40"$(CsWinRTResponseFilePrivateProjection)"</CsWinRTCommandPrivateProjection>
      <CsWinRTWindowsMetadataInput Condition="'$(CsWinRTWindowsMetadata)' != ''">-input $(CsWinRTWindowsMetadata)</CsWinRTWindowsMetadataInput>
    </PropertyGroup>

    <ItemGroup>
      <CsWinRTDetectWindowsMetadata Include="@(CsWinRTInputs)" Condition="'%(CsWinRTInputs.Filename)%(CsWinRTInputs.Extension)' == 'Windows.Foundation.FoundationContract.winmd'"></CsWinRTDetectWindowsMetadata>
      <CsWinRTDetectWindowsMetadata Include="@(CsWinRTInputs)" Condition="'%(CsWinRTInputs.Filename)%(CsWinRTInputs.Extension)' == 'Windows.winmd'"></CsWinRTDetectWindowsMetadata>
    </ItemGroup>

    <Error Condition="'$(CsWinRTParams)$(CsWinRTFilters)$(CsWinRTWindowsMetadata)@(CsWinRTDetectWindowsMetadata)' == ''"
      Text="Windows Metadata not provided or detected.  See https://github.com/microsoft/CsWinRT/tree/master/nuget/readme.md" />

    <PropertyGroup>
      <CsWinRTExcludes Condition="'$(CsWinRTExcludes)' == ''">Windows;Microsoft</CsWinRTExcludes>
      <CsWinRTExcludesPrivate Condition="'$(CsWinRTExcludesPrivate)' == ''">Windows;Microsoft</CsWinRTExcludesPrivate>
    </PropertyGroup>

    <!-- Inputs set by users -->
    <ItemGroup>
      <CsWinRTExcludePrivateItems Include="$(CsWinRTExcludesPrivate)"/>
      <CsWinRTIncludePrivateItems Include="$(CsWinRTIncludesPrivate)"/>
    </ItemGroup>

    <ItemGroup>
      <CsWinRTExcludeItems Include="$(CsWinRTExcludes)"/>
      <CsWinRTIncludeItems Include="$(CsWinRTIncludes)"/>
    </ItemGroup>

    <PropertyGroup>
      <CsWinRTPrivateFilters Condition="'$(CsWinRTPrivateFilters)' == ''">
@(CsWinRTExcludePrivateItems->'-exclude %(Identity)', '&#x0d;&#x0a;')
@(CsWinRTIncludePrivateItems->'-include %(Identity)', '&#x0d;&#x0a;')
      </CsWinRTPrivateFilters>

      <CsWinRTFilters Condition="'$(CsWinRTFilters)' == ''">
@(CsWinRTExcludeItems->'-exclude %(Identity)', '&#x0d;&#x0a;')
@(CsWinRTIncludeItems->'-include %(Identity)', '&#x0d;&#x0a;')
      </CsWinRTFilters>

      <CsWinRTInteropMetadata Condition="'$(CsWinRTInteropMetadata)' == ''">$([MSBuild]::NormalizePath('$(MSBuildThisFileDirectory)', '..\metadata\WinRT.Interop.winmd'))</CsWinRTInteropMetadata>
      <CsWinRTIncludeWinRTInterop Condition="$(CsWinRTFilters.Contains('-include Windows&#x0d;&#x0a;')) or $(CsWinRTFilters.Contains('-include Windows&#x0a;'))">
-input $(CsWinRTInteropMetadata)
-include WinRT.Interop
      </CsWinRTIncludeWinRTInterop>


      <CsWinRTPrivateIncludeWinRTInterop Condition="$(CsWinRTPrivateFilters.Contains('-include Windows&#x0d;&#x0a;')) or $(CsWinRTPrivateFilters.Contains('-include Windows&#x0a;'))">
-input $(CsWinRTInteropMetadata)
-include WinRT.Interop
      </CsWinRTPrivateIncludeWinRTInterop>

      <CsWinRTInternalProjection Condition="'$(CsWinRTPrivateProjection)' == 'true'">-internal</CsWinRTInternalProjection>
      <CsWinRTEmbeddedProjection Condition="'$(CsWinRTEmbedded)' == 'true'">-embedded</CsWinRTEmbeddedProjection>
      <CsWinRTEmbeddedEnums Condition="'$(CsWinRTEmbeddedPublicEnums)' == 'true'">-public_enums</CsWinRTEmbeddedEnums>
      <CsWinRTPublicExclusiveTo Condition="'$(CsWinRTPublicExclusiveToInterfaces)' == 'true'">-public_exclusiveto</CsWinRTPublicExclusiveTo>
      <CsWinRTDynamicallyInterfaceCastableExclusiveTo Condition="'$(CsWinRTDynamicallyInterfaceCastableExclusiveTo)' == 'true'">-idic_exclusiveto</CsWinRTDynamicallyInterfaceCastableExclusiveTo>

      <CsWinRTParams Condition="'$(CsWinRTParams)' == ''">
$(CsWinRTCommandVerbosity)
-target $(CsWinRTExeTFM)
$(CsWinRTWindowsMetadataInput)
-input @(CsWinRTInputs->'"%(FullPath)"', ' ')
-output "$(CsWinRTGeneratedFilesDir.TrimEnd('\'))"
$(CsWinRTFilters)
$(CsWinRTIncludeWinRTInterop)
$(CsWinRTEmbeddedProjection)
$(CsWinRTEmbeddedEnums)
$(CsWinRTPublicExclusiveTo)
$(CsWinRTDynamicallyInterfaceCastableExclusiveTo)
      </CsWinRTParams>

      <CsWinRTPrivateParams Condition="'$(CsWinRTPrivateParams)' == ''">
$(CsWinRTCommandVerbosity)
-target $(CsWinRTExeTFM)
$(CsWinRTWindowsMetadataInput)
-input @(CsWinRTInputs->'"%(FullPath)"', ' ')
-output "$(CsWinRTGeneratedFilesDir.TrimEnd('\'))"
$(CsWinRTPrivateFilters)
$(CsWinRTPrivateIncludeWinRTInterop)
$(CsWinRTInternalProjection)
      </CsWinRTPrivateParams>
    </PropertyGroup>

    <!-- 
      During a design-time build, generation of the CsWinRT projection might fail (e.g. input .winmds might
      not exist if a full build hasn't completed yet). To avoid causing a design-time build break, which can 
      put the design-time build results of dependent projects into a bad state, we want the build to continue
      if cswinrt.exe encounters an error during a design-time build.
    -->
    <PropertyGroup>
      <CsWinRTContinueOnError>false</CsWinRTContinueOnError>
      <CsWinRTContinueOnError Condition="'$(DesignTimeBuild)' == 'true' OR '$(BuildingProject)' != 'true'">true</CsWinRTContinueOnError>
    </PropertyGroup>

    <ItemGroup>
      <CsWinRTFilesToDelete Include="$(CsWinRTGeneratedFilesDir)*.cs"/>
    </ItemGroup>
    <Delete Files="@(CsWinRTFilesToDelete)" />
    <MakeDir Directories="$(CsWinRTGeneratedFilesDir)" />
    <WriteLinesToFile File="$(CsWinRTResponseFile)" Lines="$(CsWinRTParams)" Overwrite="true" />
    <WriteLinesToFile File="$(CsWinRTResponseFilePrivateProjection)" Lines="$(CsWinRTPrivateParams)" Overwrite="true" />
    <Message Text="$(CsWinRTCommand)" Importance="$(CsWinRTMessageImportance)" />
    <Exec Command="$(CsWinRTCommand)" ContinueOnError="$(CsWinRTContinueOnError)" />

    <Message Text="$(CsWinRTCommandPrivateProjection)" Importance="$(CsWinRTMessageImportance)" />
    <Exec Command="$(CsWinRTCommandPrivateProjection)" ContinueOnError="$(CsWinRTContinueOnError)" Condition="'$(CsWinRTPrivateProjection)' == 'true'"/>

    <ItemGroup Condition="'$(CsWinRTComponent)' != 'true' and Exists('$(CsWinRTResponseFile)')">
      <UpToDateCheckInput Include="@(CsWinRTInputs)" Set="WinMDs" />
      <UpToDateCheckInput Include="$(CsWinRTExe)" Set="WinMDs" />
      <UpToDateCheckBuilt Include="$(CsWinRTResponseFile)" Set="WinMDs" />
    </ItemGroup>

    <!-- Clean the output file if the target failed to indicate it needs to be rebuild -->
    <OnError ExecuteTargets="CsWinRTCleanGenerateProjectionOutputs" />
  </Target>

  <!-- Note: GenerateTargetFrameworkMonikerAttribute is conditional upon @(Compile) not being empty -->
  <Target Name="CsWinRTIncludeProjection" BeforeTargets="BeforeCompile;GenerateTargetFrameworkMonikerAttribute" DependsOnTargets="CsWinRTGenerateProjection" Condition="$(CsWinRTEnabled)">
    <ItemGroup>
      <Compile Include="$(CsWinRTGeneratedFilesDir)*.cs" Exclude="@(Compile)" />
    </ItemGroup>
  </Target>

  <!-- Emit a warning when 'CsWinRTMergeReferencedActivationFactories' is used incorrectly -->
  <Target
    Name="_CsWinRTErrorForInvalidMergeReferencedActivationFactories"
    BeforeTargets="BeforeCompile"
    Condition="'$(CsWinRTMergeReferencedActivationFactories)' == 'true' AND '$(PublishAot)' != 'true'">
    <Error Text="The 'CsWinRTMergeReferencedActivationFactories' property can only be set when publishing with Native AOT. Make sure to set the 'PublishAot' property to 'true'." />
  </Target>

  <!--
    Produces a stub .exe for the application, if requested. This target is only executed when publishing, and
    it's injected right after Native AOT invokes MSVC to produce the final binary, and before gathering all
    publish artifacts. It's important for this target to run right after that, so that we can make sure that
    the resulting stub .exe is gathered by the following MSIX packaging steps, which need to include it too.
  -->
  <Target
    Name="_CsWinRTGenerateStubExe"
    DependsOnTargets="PrepareForPublish"
    AfterTargets="LinkNative"
    BeforeTargets="ComputeLinkedFilesToPublish"
    Condition="'$(_CsWinRTEnableStubExeGeneration)' == 'true' AND '$(PublishAot)' == 'true'">
    <PropertyGroup>
    
      <!-- Prepare the generated files directory -->
      <_StubExeFolderName>StubExe</_StubExeFolderName>
      <_StubExeGeneratedFilesDir Condition="'$(_StubExeGeneratedFilesDir)' == '' AND '$(GeneratedFilesDir)' != ''">$(GeneratedFilesDir)\$(_StubExeFolderName)\</_StubExeGeneratedFilesDir>
      <_StubExeGeneratedFilesDir Condition="'$(_StubExeGeneratedFilesDir)' == ''">$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', 'Generated Files', '$(_StubExeFolderName)'))</_StubExeGeneratedFilesDir>
    
      <!-- The path of the .lib file produced by the Native AOT toolchain, which we need for the linker -->
      <_StubExeNativeLibraryPath>$([System.IO.Path]::Combine($(MSBuildProjectDirectory), $(NativeOutputPath), $(AssemblyName).lib))</_StubExeNativeLibraryPath>
    
      <!-- Prepare the path of the .c file with the stub .exe source we need to compile -->
      <_StubExeSourceFileName>$(AssemblyName).c</_StubExeSourceFileName>
      <_StubExeSourceFilePath>$([System.IO.Path]::Combine($(_StubExeGeneratedFilesDir), $(_StubExeSourceFileName)))</_StubExeSourceFilePath>
    
      <!-- Prepare the output path of the resulting stub .exe -->
      <_StubExeBinaryFileName>$(AssemblyName).exe</_StubExeBinaryFileName>
      <_StubExeBinaryOutputFilePath>$([System.IO.Path]::Combine($(_StubExeGeneratedFilesDir), $(_StubExeBinaryFileName)))</_StubExeBinaryOutputFilePath>
      <_StubExeBinaryDestinationFilePath>$([System.IO.Path]::Combine($(MSBuildProjectDirectory), $(NativeOutputPath), $(_StubExeBinaryFileName)))</_StubExeBinaryDestinationFilePath>

      <!-- Get the target platform (we either use 'Platform', if set and not 'AnyCPU', or fallback to 'PlatformTarget' ) -->
      <_StubExePlatform Condition="'$(_StubExePlatform)' == '' AND '$(Platform)' != '' AND '$(Platform)' != 'AnyCPU'">$(Platform)</_StubExePlatform>
      <_StubExePlatform Condition="'$(_StubExePlatform)' == '' AND '$(PlatformTarget)' != ''">$(PlatformTarget)</_StubExePlatform>
    </PropertyGroup>
    
    <!--
      This is a simple C source file just jumping into the special 'Main' program of the current project.
      Note that we need to use '%3B' to escape the semicolons, as otherwise it'll be skipped entirely.
    -->
    <PropertyGroup>
      <_StubExeSourceFileLines>
        <![CDATA[#include <wchar.h>

// Declare the import for '__managed__Main', which is a special export produced by the
// Native AOT runtime to allow jumping into the real 'Main' of an application. This is
// exported automatically when the 'CustomNativeMain' property is set to 'true'.
__declspec(dllimport)
int __stdcall __managed__Main(int argc, wchar_t** argv)%3B

// Our entry point is simply a direct jump into the entry point from Native AOT
int wmain(int argc, wchar_t** argv)
{
    return __managed__Main(argc, argv)%3B
}]]>
      </_StubExeSourceFileLines>
    </PropertyGroup>
    
    <!-- This whole target might take a minute (and it might fail), so notify the user to help debug issues -->
    <Message Text="Generating stub .exe" />

    <!-- Ensure the folder exists, or writing to the source file will fail -->
    <MakeDir Directories="$(_StubExeGeneratedFilesDir)"/>
      
    <!-- Write the stub .exe source -->
    <WriteLinesToFile Lines="$(_StubExeSourceFileLines)" Overwrite="true" WriteOnlyWhenDifferent="true" File="$(_StubExeSourceFilePath)" />

    <!--
      Get the path of 'cl.exe' from the Native AOT tooling, which finds the install folder for MSVC already.
      By doing this, we make sure that this can work from a normal terminal too, not just a VS Developer cmd.
    -->
    <PropertyGroup>
      <_ClExeFilePath Condition="'$(_ClExeFilePath)' == '' AND '$(CsWinRTUseEnvironmentalTools)' == 'true'">cl</_ClExeFilePath>
      <_ClExeFilePath Condition="'$(_ClExeFilePath)' == '' AND '$(_CppToolsDirectory)' != ''">"$([System.IO.Path]::Combine($(_CppToolsDirectory), 'cl.exe'))"</_ClExeFilePath>
    </PropertyGroup>

    <!-- Fail if we can't find any 'cl.exe' -->
    <Error
      Condition="'$(_ClExeFilePath)' == ''"
      Text="Failed to find 'cl.exe', which is needed to compile the project in the current configuration. Try setting 'CsWinRTUseEnvironmentalTools' and building from a Visual Studio Developer Command Prompt (or PowerShell) session." />

    <!-- Get the path to the include directories, if not using the environmental tools -->
    <PropertyGroup Condition="'$(CsWinRTUseEnvironmentalTools)' != 'true'">

      <!-- Find the 'include' folder in the MSVC install folder -->
      <_MsvcCurrentVersionInstallDirectory>$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine($(_CppToolsDirectory), '..', '..', '..'))))</_MsvcCurrentVersionInstallDirectory>
      <_MsvcIncludePath>$([System.IO.Path]::Combine($(_MsvcCurrentVersionInstallDirectory), 'include'))</_MsvcIncludePath>
      <_MsvcLibPath>$([System.IO.Path]::Combine($(_MsvcCurrentVersionInstallDirectory), 'lib', '$(_StubExePlatform)'))</_MsvcLibPath>
      <_MsvcLibWildcardPath>$([System.IO.Path]::Combine($(_MsvcLibPath), '*.lib'))</_MsvcLibWildcardPath>

      <!-- Also get the root for the Windows SDK headers -->
      <_WindowsSdk10InstallDirectory Condition="'$(_WindowsSdk10InstallDirectory)' == '' AND '$(WindowsSdkPath)' != ''">$(WindowsSdkPath)</_WindowsSdk10InstallDirectory>
      <_WindowsSdk10InstallDirectory Condition="'$(_WindowsSdk10InstallDirectory)' == ''">C:\Program Files (x86)\Windows Kits\10</_WindowsSdk10InstallDirectory>
      <_WindowsSdkIncludePath Condition="'$(TargetPlatformVersion)' != ''">$([System.IO.Path]::Combine($(_WindowsSdk10InstallDirectory), 'Include', '$(TargetPlatformVersion)'))</_WindowsSdkIncludePath>
      <_WindowsSdk-ucrt-IncludePath>$([System.IO.Path]::Combine($(_WindowsSdkIncludePath), 'ucrt'))</_WindowsSdk-ucrt-IncludePath>
      <_WindowsSdk-um-IncludePath>$([System.IO.Path]::Combine($(_WindowsSdkIncludePath), 'um'))</_WindowsSdk-um-IncludePath>

      <!-- Do the same for libs as well -->
      <_WindowsSdkLibPath Condition="'$(TargetPlatformVersion)' != ''">$([System.IO.Path]::Combine($(_WindowsSdk10InstallDirectory), 'Lib', '$(TargetPlatformVersion)'))</_WindowsSdkLibPath>
      <_WindowsSdk-ucrt-LibPath>$([System.IO.Path]::Combine($(_WindowsSdkLibPath), 'ucrt', '$(_StubExePlatform)'))</_WindowsSdk-ucrt-LibPath>
      <_WindowsSdk-um-LibPath>$([System.IO.Path]::Combine($(_WindowsSdkLibPath), 'um', '$(_StubExePlatform)'))</_WindowsSdk-um-LibPath>
      <_WindowsSdk-ucrt-LibWildcardPath>$([System.IO.Path]::Combine($(_WindowsSdk-ucrt-LibPath), '*.lib'))</_WindowsSdk-ucrt-LibWildcardPath>
      <_WindowsSdk-um-LibWildcardPath>$([System.IO.Path]::Combine($(_WindowsSdk-um-LibPath), '*.lib'))</_WindowsSdk-um-LibWildcardPath>
    </PropertyGroup>

    <!-- We can't find some of the additional include folders -->
    <Error
      Condition="'$(CsWinRTUseEnvironmentalTools)' != 'true' AND ('$(_MsvcIncludePath)' == '' OR !Exists('$(_MsvcIncludePath)') OR '$(_WindowsSdkIncludePath)' == '' OR !Exists('$(_WindowsSdkIncludePath)'))"
      Text="Failed to find the paths for the include folders to pass to MSVC, which are needed to compile the project in the current configuration. Try setting 'CsWinRTUseEnvironmentalTools' and building from a Visual Studio Developer Command Prompt (or PowerShell) session." />
    
    <!-- Error on unsupported platforms -->
    <Error
      Condition="'$(CsWinRTUseEnvironmentalTools)' != 'true' AND '$(_StubExePlatform)' != 'arm64' AND '$(_StubExePlatform)' != 'x64' AND '$(_StubExePlatform)' != 'x86'"
      Text="Invalid platform selected to invoke MSVC. Make sure to set 'Platform' to either 'arm64', 'x64', or 'x86'. Alternatively, try setting 'CsWinRTUseEnvironmentalTools' and building from a Visual Studio Developer Command Prompt (or PowerShell) session." />

    <!-- Prepare the arguments for MSVC -->
    <ItemGroup>

      <!-- If not using the environmental tools, manually pass the paths to the required libs -->
      <_StubExeMsvcArgs Condition="'$(CsWinRTUseEnvironmentalTools)' != 'true'" Include='"$(_MsvcLibWildcardPath)"' />
      <_StubExeMsvcArgs Condition="'$(CsWinRTUseEnvironmentalTools)' != 'true'" Include='"$(_WindowsSdk-ucrt-LibWildcardPath)"' />
      <_StubExeMsvcArgs Condition="'$(CsWinRTUseEnvironmentalTools)' != 'true'" Include='"$(_WindowsSdk-um-LibWildcardPath)"' />

      <!-- Hide the copyright banner, to reduce visual clutter (https://learn.microsoft.com/cpp/build/reference/nologo-suppress-startup-banner-c-cpp) -->
      <_StubExeMsvcArgs Include="/nologo" />

      <!-- If not using the environmental tools, also pass the paths to the necessary include folders -->
      <_StubExeMsvcArgs Condition="'$(CsWinRTUseEnvironmentalTools)' != 'true'" Include='/I "$(_MsvcIncludePath)"' />
      <_StubExeMsvcArgs Condition="'$(CsWinRTUseEnvironmentalTools)' != 'true'" Include='/I "$(_WindowsSdk-ucrt-IncludePath)"' />
      <_StubExeMsvcArgs Condition="'$(CsWinRTUseEnvironmentalTools)' != 'true'" Include='/I "$(_WindowsSdk-um-IncludePath)"' />

      <!--
        Configure the binary to statically link the C runtime library (https://learn.microsoft.com/cpp/build/reference/md-mt-ld-use-run-time-library).
        This library (UCRT) has the implementation of all standard C runtime methods, like 'printf'. We want to actually link it dynamically, so we
        will opt-in that individual library below. The dynamically linked version ships in the OS as 'ucrt.dll'. This matches the behavior of
        Native AOT as well, which links UCRT dynamically, and VCRUNTIME140 (the MSVC-specific part of the C runtime) statically. The latter is much
        smaller in size, so it does not matter. Dynamically linking UCRT reduces the size from 98 KB to 20 KB. The reason why we're not configuring
        libraries to be dynamically linked, and then just having an opt-out for VCRUNTIME140, is that doing so causes a linker warning.
      -->
      <_StubExeMsvcArgs Condition="'$(Configuration)' == 'Debug'" Include="/MTd" />
      <_StubExeMsvcArgs Condition="'$(Configuration)' != 'Debug'" Include="/MT" />

      <!-- Optimize for speed (https://learn.microsoft.com/cpp/build/reference/o1-o2-minimize-size-maximize-speed) -->
      <_StubExeMsvcArgs Include="/O2" />

      <!-- Denote the start of the sequence of linker options (https://learn.microsoft.com/cpp/build/reference/compiler-command-line-syntax) -->
      <_StubExeMsvcArgs Include="/link" />

      <!-- Hide the copyright banner for the linker as well -->
      <_StubExeMsvcArgs Include="/NOLOGO" />

      <!-- Skip generating a manifest file, matching Native AOT (https://learn.microsoft.com/cpp/build/reference/manifest-create-side-by-side-assembly-manifest) -->
      <_StubExeMsvcArgs Include="/MANIFEST:NO" />

      <!--
        Change the behavior for UCRT to be dynamically linked (the default would be to statically link it, due to '/MT[d]').
        See: https://learn.microsoft.com/cpp/build/reference/defaultlib-specify-default-library.
        Also see: https://learn.microsoft.com/cpp/build/reference/nodefaultlib-ignore-libraries.
      -->
      <_StubExeMsvcArgs Include="/NODEFAULTLIB:libucrt.lib" />
      <_StubExeMsvcArgs Include="/DEFAULTLIB:ucrt.lib" />

      <!-- Skip generating additional code for incremental linking (https://learn.microsoft.com/cpp/build/reference/incremental-link-incrementally) -->
      <_StubExeMsvcArgs Include="/INCREMENTAL:NO" />

      <!-- Enable COMDAT folding and remove unreferenced code (https://learn.microsoft.com/cpp/build/reference/opt-optimizations) -->
      <_StubExeMsvcArgs Include="/OPT:ICF" />
      <_StubExeMsvcArgs Include="/OPT:REF" />

      <!--
        Set the bit for AppContainer, for UWP apps (https://learn.microsoft.com/cpp/build/reference/appcontainer-windows-store-app).
        This is not strictly needed on new Windows versions, but doing so matches the behavior of .NET Native as well.
      -->
      <_StubExeMsvcArgs Condition="'$(UseUwpTools)' == 'true'" Include="/APPCONTAINER" />

      <!-- Set the right subsystem type, to match the project type (https://learn.microsoft.com/cpp/build/reference/subsystem-specify-subsystem) -->
      <_StubExeMsvcArgs Condition="'$(OutputType)' == 'WinExe'" Include="/SUBSYSTEM:WINDOWS" />
      <_StubExeMsvcArgs Condition="'$(OutputType)' != 'WinExe'" Include="/SUBSYSTEM:CONSOLE" />

      <!--
        Always set 'wmainCRTStartup' as the entry point (https://learn.microsoft.com/cpp/build/reference/entry-entry-point-symbol).
        This matches what Native AOT does, and it allows us to always use 'wmain' for all application types, including 'WinExe'.
      -->
      <_StubExeMsvcArgs Include="/ENTRY:wmainCRTStartup" />

      <!-- Enable CFG, if requested (https://learn.microsoft.com/cpp/build/reference/guard-enable-control-flow-guard) -->
      <_StubExeMsvcArgs Condition="'$(ControlFlowGuard)' == 'Guard'" Include="/guard:cf" />

      <!-- Configure the CET shadow stack compatibility (https://learn.microsoft.com/cpp/build/reference/cetcompat) -->
      <_StubExeMsvcArgs Condition="'$(CETCompat)' != 'false' and '$(_StubExePlatform)' == 'x64'" Include="/CETCOMPAT" />
      <_StubExeMsvcArgs Condition="'$(CETCompat)' == 'false' and '$(_StubExePlatform)' == 'x64'" Include="/CETCOMPAT:NO" />

      <!--
        Enable EH continuation metadata if CET is not disabled and CFG is enabled, to match what Native AOT does.
        See: https://learn.microsoft.com/cpp/build/reference/guard-enable-eh-continuation-metadata.
      -->
      <_StubExeMsvcArgs Condition="'$(CETCompat)' != 'false' and '$(_StubExePlatform)' == 'x64' and '$(ControlFlowGuard)' == 'Guard'" Include="/guard:ehcont"/>
    </ItemGroup>

    <!-- Combine all arguments, separated by a space (also, using a property makes it easier to inspect them, for debugging) -->
    <PropertyGroup>
      <_StubExeMsvcArgsText>@(_StubExeMsvcArgs, ' ')</_StubExeMsvcArgsText>
    </PropertyGroup>
    
    <!--
      Remove the broken .exe, if present (see https://github.com/dotnet/runtime/issues/111313). We want to do this before
      compiling the binary, to ensure users won't ever see the wrong one in the publish folder and use that by accident.
    -->
    <Delete Files="$(_StubExeBinaryDestinationFilePath)" />
    
    <!-- Invoke MSVC to produce the native executable -->
    <Exec
      Command='$(_ClExeFilePath) "$(_StubExeSourceFilePath)" "$(_StubExeNativeLibraryPath)" $(_StubExeMsvcArgsText)'
      ConsoleToMsBuild="true"
      WorkingDirectory="$(_StubExeGeneratedFilesDir)" />
    
    <!-- Copy the resulting executable to the native directory -->
    <Copy SourceFiles="$(_StubExeBinaryOutputFilePath)" DestinationFiles="$(_StubExeBinaryDestinationFilePath)" />

    <!-- Also mark the stub .exe as being part of the published items (so it's gathered by the PRI/MSIX tools) -->
    <ItemGroup>
      <ResolvedFileToPublish Include="$(_StubExeBinaryDestinationFilePath)" Condition="'$(CopyBuildOutputToPublishDirectory)' == 'true'">
        <RelativePath>$(_StubExeBinaryFileName)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>

  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.Prerelease.targets" Condition="Exists('$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.Prerelease.targets')"/>
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.Authoring.targets" Condition="'$(CsWinRTComponent)' == 'true'"/>
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.Windows.CsWinRT.IIDOptimizer.targets" Condition="'$(CsWinRTIIDOptimizerOptOut)' != 'true'"/>

  <!-- Default values for all custom CsWinRT runtime feature switches -->
  <PropertyGroup>
    <CsWinRTEnableDynamicObjectsSupport Condition="'$(CsWinRTEnableDynamicObjectsSupport)' == ''">true</CsWinRTEnableDynamicObjectsSupport>
    <CsWinRTUseExceptionResourceKeys Condition="'$(CsWinRTUseExceptionResourceKeys)' == ''">false</CsWinRTUseExceptionResourceKeys>
    <CsWinRTEnableDefaultCustomTypeMappings Condition="'$(CsWinRTEnableDefaultCustomTypeMappings)' == ''">true</CsWinRTEnableDefaultCustomTypeMappings>
    <CsWinRTEnableICustomPropertyProviderSupport Condition="'$(CsWinRTEnableICustomPropertyProviderSupport)' == ''">true</CsWinRTEnableICustomPropertyProviderSupport>
    <CsWinRTEnableIReferenceSupport Condition="'$(CsWinRTEnableIReferenceSupport)' == ''">true</CsWinRTEnableIReferenceSupport>
    <CsWinRTEnableIDynamicInterfaceCastableSupport Condition="'$(CsWinRTEnableIDynamicInterfaceCastableSupport)' == ''">true</CsWinRTEnableIDynamicInterfaceCastableSupport>
    <CsWinRTEnableManifestFreeActivation Condition="'$(CsWinRTEnableManifestFreeActivation)' == ''">true</CsWinRTEnableManifestFreeActivation>
    <CsWinRTManifestFreeActivationReportOriginalException Condition="'$(CsWinRTManifestFreeActivationReportOriginalException)' == ''">false</CsWinRTManifestFreeActivationReportOriginalException>

    <!--
      Note: the 'CsWinRTUseWindowsUIXamlProjections' property and associated 'CSWINRT_USE_WINDOWS_UI_XAML_PROJECTIONS' feature
      switch are set by the .NET SDK, so that the right projection mode is enabled even when CsWinRT is not directly referenced.
    -->
  </PropertyGroup>

  <!--
    Configuration for the feature switches (to support IL trimming).
    See the 'ILLink.Substitutions.xml' file for more details on that.
  -->
  <ItemGroup>

    <!-- CSWINRT_ENABLE_DYNAMIC_OBJECTS_SUPPORT switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_DYNAMIC_OBJECTS_SUPPORT"
                                    Value="$(CsWinRTEnableDynamicObjectsSupport)"
                                    Trim="true" />

    <!-- CSWINRT_USE_EXCEPTION_RESOURCE_KEYS switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_USE_EXCEPTION_RESOURCE_KEYS"
                                    Value="$(CsWinRTUseExceptionResourceKeys)"
                                    Trim="true" />
                                  
    <!-- CSWINRT_ENABLE_DEFAULT_CUSTOM_TYPE_MAPPINGS switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_DEFAULT_CUSTOM_TYPE_MAPPINGS"
                                    Value="$(CsWinRTEnableDefaultCustomTypeMappings)"
                                    Trim="true" />

    <!-- CSWINRT_ENABLE_ICUSTOMPROPERTYPROVIDER_SUPPORT switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_ICUSTOMPROPERTYPROVIDER_SUPPORT"
                                    Value="$(CsWinRTEnableICustomPropertyProviderSupport)"
                                    Trim="true" />
    
    <!-- CSWINRT_ENABLE_IREFERENCE_SUPPORT switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_IREFERENCE_SUPPORT"
                                    Value="$(CsWinRTEnableIReferenceSupport)"
                                    Trim="true" />

    <!-- CSWINRT_ENABLE_IDYNAMICINTERFACECASTABLE switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_IDYNAMICINTERFACECASTABLE"
                                    Value="$(CsWinRTEnableIDynamicInterfaceCastableSupport)"
                                    Trim="true" />

    <!-- CSWINRT_ENABLE_MANIFEST_FREE_ACTIVATION switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_ENABLE_MANIFEST_FREE_ACTIVATION"
                                    Value="$(CsWinRTEnableManifestFreeActivation)"
                                    Trim="true" />

    <!-- CSWINRT_MANIFEST_FREE_ACTIVATION_REPORT_ORIGINAL_EXCEPTION switch -->
    <RuntimeHostConfigurationOption Include="CSWINRT_MANIFEST_FREE_ACTIVATION_REPORT_ORIGINAL_EXCEPTION"
                                    Value="$(CsWinRTManifestFreeActivationReportOriginalException)"
                                    Trim="true" />
  </ItemGroup>

</Project>
