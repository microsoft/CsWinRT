//------------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by cswinrt.exe version 0.0.0-private.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using Windows.Foundation;
using WindowsRuntime;
using WindowsRuntime.InteropServices;
using WindowsRuntime.InteropServices.Marshalling;
using static System.Runtime.InteropServices.ComWrappers;

#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace TestComponent
{
    [WindowsRuntimeMetadata("TestComponent")]
    [WindowsRuntimeClassName("Windows.Foundation.IReference<TestComponent.Blittable>")]
    [ABI.TestComponent.BlittableComWrappersMarshaller]
    public struct Blittable: IEquatable<Blittable>
    {
        public Blittable(byte _A, ushort _B, uint _C, ulong _D, short _E, int _F, long _G, float _H, double _I, Guid _J)
        {
            A = _A; B = _B; C = _C; D = _D; E = _E; F = _F; G = _G; H = _H; I = _I; J = _J; 
        }
        public byte A
        {
            readonly get; set;
        }
        public ushort B
        {
            readonly get; set;
        }
        public uint C
        {
            readonly get; set;
        }
        public ulong D
        {
            readonly get; set;
        }
        public short E
        {
            readonly get; set;
        }
        public int F
        {
            readonly get; set;
        }
        public long G
        {
            readonly get; set;
        }
        public float H
        {
            readonly get; set;
        }
        public double I
        {
            readonly get; set;
        }
        public Guid J
        {
            readonly get; set;
        }
        public static bool operator ==(Blittable x, Blittable y) => x.A == y.A && x.B == y.B && x.C == y.C && x.D == y.D && x.E == y.E && x.F == y.F && x.G == y.G && x.H == y.H && x.I == y.I && x.J == y.J;
        public static bool operator !=(Blittable x, Blittable y) => !(x == y);
        public bool Equals(Blittable other) => this == other;
        public override bool Equals(object obj) => obj is Blittable that && this == that;
        public override int GetHashCode() => A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode() ^ E.GetHashCode() ^ F.GetHashCode() ^ G.GetHashCode() ^ H.GetHashCode() ^ I.GetHashCode() ^ J.GetHashCode();
    }
    [WindowsRuntimeMetadata("TestComponent")]
    [WindowsRuntimeClassName("Windows.Foundation.IReference<TestComponent.Nested>")]
    [ABI.TestComponent.NestedComWrappersMarshaller]
    public struct Nested: IEquatable<Nested>
    {
        public Nested(Blittable _Blittable, NonBlittable _NonBlittable)
        {
            Blittable = _Blittable; NonBlittable = _NonBlittable; 
        }
        public Blittable Blittable
        {
            readonly get; set;
        }
        public NonBlittable NonBlittable
        {
            readonly get; set;
        }
        public static bool operator ==(Nested x, Nested y) => x.Blittable == y.Blittable && x.NonBlittable == y.NonBlittable;
        public static bool operator !=(Nested x, Nested y) => !(x == y);
        public bool Equals(Nested other) => this == other;
        public override bool Equals(object obj) => obj is Nested that && this == that;
        public override int GetHashCode() => Blittable.GetHashCode() ^ NonBlittable.GetHashCode();
    }
    [WindowsRuntimeMetadata("TestComponent")]
    [WindowsRuntimeClassName("Windows.Foundation.IReference<TestComponent.NonBlittable>")]
    [ABI.TestComponent.NonBlittableComWrappersMarshaller]
    public struct NonBlittable: IEquatable<NonBlittable>
    {
        public NonBlittable(bool _A, char _B, string _C, global::System.Nullable<long> _D)
        {
            A = _A; B = _B; C = _C; D = _D; 
        }
        public bool A
        {
            readonly get; set;
        }
        public char B
        {
            readonly get; set;
        }
        public string C
        {
            readonly get; set;
        }
        public global::System.Nullable<long> D
        {
            readonly get; set;
        }
        public static bool operator ==(NonBlittable x, NonBlittable y) => x.A == y.A && x.B == y.B && x.C == y.C && x.D == y.D;
        public static bool operator !=(NonBlittable x, NonBlittable y) => !(x == y);
        public bool Equals(NonBlittable other) => this == other;
        public override bool Equals(object obj) => obj is NonBlittable that && this == that;
        public override int GetHashCode() => A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();
    }
}

#pragma warning disable CA1416
namespace ABI.TestComponent
{

    // ---------------- abi struct implemention for global::TestComponent.Blittable  ----------------  
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public static unsafe class BlittableMarshaller
    {
        public static WindowsRuntimeObjectReferenceValue BoxToUnmanaged(global::TestComponent.Blittable? value)
        {
            return WindowsRuntimeValueTypeMarshaller.BoxToUnmanaged(value, in BlittableReferenceImpl.IID_IReferenceOfBlittable);
        }
        public static global::TestComponent.Blittable? UnboxToManaged(void* value)
        {
            return WindowsRuntimeValueTypeMarshaller.UnboxToManaged<global::TestComponent.Blittable>(value);
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    file struct BlittableInterfaceEntries
    {
        public ComInterfaceEntry IReferenceOfBlittable;
        public ComInterfaceEntry IPropertyValue;
        public ComInterfaceEntry IStringable;
        public ComInterfaceEntry IWeakReferenceSource;
        public ComInterfaceEntry IMarshal;
        public ComInterfaceEntry IAgileObject;
        public ComInterfaceEntry IInspectable;
        public ComInterfaceEntry IUnknown;
    }

    file static class BlittableInterfaceEntriesImpl
    {
        [FixedAddressValueType]
        public static readonly BlittableInterfaceEntries Entries;
        
        static BlittableInterfaceEntriesImpl()
        {
            Entries.IReferenceOfBlittable.IID = BlittableReferenceImpl.IID_IReferenceOfBlittable;
            Entries.IReferenceOfBlittable.Vtable = BlittableReferenceImpl.Vtable;
            Entries.IPropertyValue.IID = IPropertyValueImpl.IID;
            Entries.IPropertyValue.Vtable = IPropertyValueImpl.OtherTypeVtable;
            Entries.IStringable.IID = IStringableImpl.IID;
            Entries.IStringable.Vtable = IStringableImpl.Vtable;
            Entries.IWeakReferenceSource.IID = IWeakReferenceSourceImpl.IID;
            Entries.IWeakReferenceSource.Vtable = IWeakReferenceSourceImpl.Vtable;
            Entries.IMarshal.IID = IMarshalImpl.IID;
            Entries.IMarshal.Vtable = IMarshalImpl.Vtable;
            Entries.IAgileObject.IID = IAgileObjectImpl.IID;
            Entries.IAgileObject.Vtable = IAgileObjectImpl.Vtable;
            Entries.IInspectable.IID = IInspectableImpl.IID;
            Entries.IInspectable.Vtable = IInspectableImpl.Vtable;
            Entries.IUnknown.IID = IUnknownImpl.IID;
            Entries.IUnknown.Vtable = IUnknownImpl.Vtable;
        }
    }

    internal sealed unsafe class BlittableComWrappersMarshallerAttribute : WindowsRuntimeComWrappersMarshallerAttribute
    {
        public override void* GetOrCreateComInterfaceForObject(object value)
        {
            return WindowsRuntimeValueTypeMarshaller.BoxToUnmanaged<global::TestComponent.Blittable>((global::TestComponent.Blittable) value, in BlittableReferenceImpl.IID_IReferenceOfBlittable).DetachThisPtrUnsafe();
        }

        public override ComInterfaceEntry* ComputeVtables(out int count)
        {
            count = sizeof(BlittableInterfaceEntries) / sizeof(ComInterfaceEntry);
            return (ComInterfaceEntry*)Unsafe.AsPointer(in BlittableInterfaceEntriesImpl.Entries);
        }

        public override object CreateObject(void* value, out CreatedWrapperFlags wrapperFlags)
        {
            wrapperFlags = CreatedWrapperFlags.NonWrapping;
            return WindowsRuntimeValueTypeMarshaller.UnboxToManagedUnsafe<global::TestComponent.Blittable>(value, in BlittableReferenceImpl.IID_IReferenceOfBlittable);
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    file unsafe struct BlittableReferenceVftbl
    {
        public delegate* unmanaged[MemberFunction]<void*, Guid*, void**, int> QueryInterface;
        public delegate* unmanaged[MemberFunction]<void*, uint> AddRef;
        public delegate* unmanaged[MemberFunction]<void*, uint> Release;
        public delegate* unmanaged[MemberFunction]<void*, uint*, Guid**, int> GetIids;
        public delegate* unmanaged[MemberFunction]<void*, void**, int> GetRuntimeClassName;
        public delegate* unmanaged[MemberFunction]<void*, TrustLevel*, int> GetTrustLevel;
        public delegate* unmanaged[MemberFunction]<void*, global::TestComponent.Blittable*, int> get_Value;
    }

    file static unsafe class BlittableReferenceImpl
    {
        [FixedAddressValueType]
        private static readonly BlittableReferenceVftbl Vftbl;

        private const int S_OK = unchecked((int)0x00000000);
        private const int E_POINTER = unchecked((int)0x80004003);

        static BlittableReferenceImpl()
        {
            *(IInspectableVftbl*)Unsafe.AsPointer(ref Vftbl) = *(IInspectableVftbl*)IInspectableImpl.Vtable;
            Vftbl.get_Value = &get_Value;
        }

        public static nint Vtable
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (nint)Unsafe.AsPointer(in Vftbl);
        }

        [UnmanagedCallersOnly(CallConvs = [typeof(CallConvMemberFunction)])]
        public static int get_Value(void* thisPtr, global::TestComponent.Blittable* result)
        {
            if (result is null)
            {
                return E_POINTER;
            }

            try
            {
                *result = (global::TestComponent.Blittable)(ComInterfaceDispatch.GetInstance<object>((ComInterfaceDispatch*)thisPtr));
                return S_OK;
            }
            catch (Exception e)
            {
                return RestrictedErrorInfoExceptionMarshaller.ConvertToUnmanaged(e);
            }
        }

        public static ref readonly Guid IID_IReferenceOfBlittable
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                ReadOnlySpan<byte> data =
                [
                    0xA6, 0x5, 0x73, 0x26,
                    0xE4, 0x6F,
                    0x1D, 0x58,
                    0x8C,
                    0xE9,
                    0xAD,
                    0xFE,
                    0xF,
                    0xE6,
                    0x6B,
                    0xC7
                ];
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
            }
        }
        
    }

    // ---------------- abi struct implemention for global::TestComponent.Nested  ----------------  
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [WindowsRuntimeClassName("Windows.Foundation.IReference<TestComponent.Nested>")]
    [ABI.TestComponent.NestedComWrappersMarshaller]
    public struct Nested
    {
        public global::TestComponent.Blittable Blittable;
        public NonBlittable NonBlittable;
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public static unsafe class NestedMarshaller
    {
        public static Nested ConvertToUnmanaged(global::TestComponent.Nested value)
        {
            return new() {
                Blittable = value.Blittable,
                NonBlittable = NonBlittableMarshaller.ConvertToUnmanaged(value.NonBlittable)
            };
        }
        public static global::TestComponent.Nested ConvertToManaged(Nested value)
        {
            return new global::TestComponent.Nested(
                value.Blittable,
                NonBlittableMarshaller.ConvertToManaged(value.NonBlittable)
            );
        }
        public static WindowsRuntimeObjectReferenceValue BoxToUnmanaged(global::TestComponent.Nested? value)
        {
            return WindowsRuntimeValueTypeMarshaller.BoxToUnmanaged(value, in NestedReferenceImpl.IID_IReferenceOfNested);
        }
        public static global::TestComponent.Nested? UnboxToManaged(void* value)
        {
            Nested? abi = WindowsRuntimeValueTypeMarshaller.UnboxToManaged<Nested>(value);
            return abi.HasValue ? ConvertToManaged(abi.GetValueOrDefault()) : null;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    file struct NestedInterfaceEntries
    {
        public ComInterfaceEntry IReferenceOfNested;
        public ComInterfaceEntry IPropertyValue;
        public ComInterfaceEntry IStringable;
        public ComInterfaceEntry IWeakReferenceSource;
        public ComInterfaceEntry IMarshal;
        public ComInterfaceEntry IAgileObject;
        public ComInterfaceEntry IInspectable;
        public ComInterfaceEntry IUnknown;
    }

    file static class NestedInterfaceEntriesImpl
    {
        [FixedAddressValueType]
        public static readonly NestedInterfaceEntries Entries;
        
        static NestedInterfaceEntriesImpl()
        {
            Entries.IReferenceOfNested.IID = NestedReferenceImpl.IID_IReferenceOfNested;
            Entries.IReferenceOfNested.Vtable = NestedReferenceImpl.Vtable;
            Entries.IPropertyValue.IID = IPropertyValueImpl.IID;
            Entries.IPropertyValue.Vtable = IPropertyValueImpl.OtherTypeVtable;
            Entries.IStringable.IID = IStringableImpl.IID;
            Entries.IStringable.Vtable = IStringableImpl.Vtable;
            Entries.IWeakReferenceSource.IID = IWeakReferenceSourceImpl.IID;
            Entries.IWeakReferenceSource.Vtable = IWeakReferenceSourceImpl.Vtable;
            Entries.IMarshal.IID = IMarshalImpl.IID;
            Entries.IMarshal.Vtable = IMarshalImpl.Vtable;
            Entries.IAgileObject.IID = IAgileObjectImpl.IID;
            Entries.IAgileObject.Vtable = IAgileObjectImpl.Vtable;
            Entries.IInspectable.IID = IInspectableImpl.IID;
            Entries.IInspectable.Vtable = IInspectableImpl.Vtable;
            Entries.IUnknown.IID = IUnknownImpl.IID;
            Entries.IUnknown.Vtable = IUnknownImpl.Vtable;
        }
    }

    internal sealed unsafe class NestedComWrappersMarshallerAttribute : WindowsRuntimeComWrappersMarshallerAttribute
    {
        public override void* GetOrCreateComInterfaceForObject(object value)
        {
            return WindowsRuntimeValueTypeMarshaller.BoxToUnmanaged<global::TestComponent.Nested>((global::TestComponent.Nested) value, in NestedReferenceImpl.IID_IReferenceOfNested).DetachThisPtrUnsafe();
        }

        public override ComInterfaceEntry* ComputeVtables(out int count)
        {
            count = sizeof(NestedInterfaceEntries) / sizeof(ComInterfaceEntry);
            return (ComInterfaceEntry*)Unsafe.AsPointer(in NestedInterfaceEntriesImpl.Entries);
        }

        public override object CreateObject(void* value, out CreatedWrapperFlags wrapperFlags)
        {
            wrapperFlags = CreatedWrapperFlags.NonWrapping;
            return WindowsRuntimeValueTypeMarshaller.UnboxToManagedUnsafe<Nested>(value, in NestedReferenceImpl.IID_IReferenceOfNested);
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    file unsafe struct NestedReferenceVftbl
    {
        public delegate* unmanaged[MemberFunction]<void*, Guid*, void**, int> QueryInterface;
        public delegate* unmanaged[MemberFunction]<void*, uint> AddRef;
        public delegate* unmanaged[MemberFunction]<void*, uint> Release;
        public delegate* unmanaged[MemberFunction]<void*, uint*, Guid**, int> GetIids;
        public delegate* unmanaged[MemberFunction]<void*, void**, int> GetRuntimeClassName;
        public delegate* unmanaged[MemberFunction]<void*, TrustLevel*, int> GetTrustLevel;
        public delegate* unmanaged[MemberFunction]<void*, Nested*, int> get_Value;
    }

    file static unsafe class NestedReferenceImpl
    {
        [FixedAddressValueType]
        private static readonly NestedReferenceVftbl Vftbl;

        private const int S_OK = unchecked((int)0x00000000);
        private const int E_POINTER = unchecked((int)0x80004003);

        static NestedReferenceImpl()
        {
            *(IInspectableVftbl*)Unsafe.AsPointer(ref Vftbl) = *(IInspectableVftbl*)IInspectableImpl.Vtable;
            Vftbl.get_Value = &get_Value;
        }

        public static nint Vtable
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (nint)Unsafe.AsPointer(in Vftbl);
        }

        [UnmanagedCallersOnly(CallConvs = [typeof(CallConvMemberFunction)])]
        public static int get_Value(void* thisPtr, Nested* result)
        {
            if (result is null)
            {
                return E_POINTER;
            }

            try
            {
                *result = (Nested)(ComInterfaceDispatch.GetInstance<object>((ComInterfaceDispatch*)thisPtr));
                return S_OK;
            }
            catch (Exception e)
            {
                return RestrictedErrorInfoExceptionMarshaller.ConvertToUnmanaged(e);
            }
        }

        public static ref readonly Guid IID_IReferenceOfNested
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                ReadOnlySpan<byte> data =
                [
                    0x1E, 0x1E, 0xF8, 0x15,
                    0x77, 0x43,
                    0xA3, 0x5C,
                    0x91,
                    0x1B,
                    0x1C,
                    0xA2,
                    0xE,
                    0x25,
                    0x2,
                    0x1C
                ];
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
            }
        }
        
    }

    // ---------------- abi struct implemention for global::TestComponent.NonBlittable  ----------------  
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    [WindowsRuntimeClassName("Windows.Foundation.IReference<TestComponent.NonBlittable>")]
    [ABI.TestComponent.NonBlittableComWrappersMarshaller]
    public struct NonBlittable
    {
        public byte A;
        public ushort B;
        public nint C;
        public nint D;
    }

    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public static unsafe class NonBlittableMarshaller
    {
        public static NonBlittable ConvertToUnmanaged(global::TestComponent.NonBlittable value)
        {
            return new() {
                A = value.A ? (byte)1 : (byte)0,
                B = (ushort)value.B,
                C = (nint)HStringMarshaller.ConvertToUnmanaged(value.C),
                D = (nint)ABI.System.Int64Marshaller.BoxToUnmanaged(value.D).DetachThisPtrUnsafe()
            };
        }
        public static global::TestComponent.NonBlittable ConvertToManaged(NonBlittable value)
        {
            return new global::TestComponent.NonBlittable(
                value.A != 0,
                (char)value.B,
                HStringMarshaller.ConvertToManaged((void*)value.C),
                ABI.System.Int64Marshaller.UnboxToManaged((void*)value.D)
            );
        }
        public static WindowsRuntimeObjectReferenceValue BoxToUnmanaged(global::TestComponent.NonBlittable? value)
        {
            return WindowsRuntimeValueTypeMarshaller.BoxToUnmanaged(value, in NonBlittableReferenceImpl.IID_IReferenceOfNonBlittable);
        }
        public static global::TestComponent.NonBlittable? UnboxToManaged(void* value)
        {
            NonBlittable? abi = WindowsRuntimeValueTypeMarshaller.UnboxToManaged<NonBlittable>(value);
            return abi.HasValue ? ConvertToManaged(abi.GetValueOrDefault()) : null;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    file struct NonBlittableInterfaceEntries
    {
        public ComInterfaceEntry IReferenceOfNonBlittable;
        public ComInterfaceEntry IPropertyValue;
        public ComInterfaceEntry IStringable;
        public ComInterfaceEntry IWeakReferenceSource;
        public ComInterfaceEntry IMarshal;
        public ComInterfaceEntry IAgileObject;
        public ComInterfaceEntry IInspectable;
        public ComInterfaceEntry IUnknown;
    }

    file static class NonBlittableInterfaceEntriesImpl
    {
        [FixedAddressValueType]
        public static readonly NonBlittableInterfaceEntries Entries;
        
        static NonBlittableInterfaceEntriesImpl()
        {
            Entries.IReferenceOfNonBlittable.IID = NonBlittableReferenceImpl.IID_IReferenceOfNonBlittable;
            Entries.IReferenceOfNonBlittable.Vtable = NonBlittableReferenceImpl.Vtable;
            Entries.IPropertyValue.IID = IPropertyValueImpl.IID;
            Entries.IPropertyValue.Vtable = IPropertyValueImpl.OtherTypeVtable;
            Entries.IStringable.IID = IStringableImpl.IID;
            Entries.IStringable.Vtable = IStringableImpl.Vtable;
            Entries.IWeakReferenceSource.IID = IWeakReferenceSourceImpl.IID;
            Entries.IWeakReferenceSource.Vtable = IWeakReferenceSourceImpl.Vtable;
            Entries.IMarshal.IID = IMarshalImpl.IID;
            Entries.IMarshal.Vtable = IMarshalImpl.Vtable;
            Entries.IAgileObject.IID = IAgileObjectImpl.IID;
            Entries.IAgileObject.Vtable = IAgileObjectImpl.Vtable;
            Entries.IInspectable.IID = IInspectableImpl.IID;
            Entries.IInspectable.Vtable = IInspectableImpl.Vtable;
            Entries.IUnknown.IID = IUnknownImpl.IID;
            Entries.IUnknown.Vtable = IUnknownImpl.Vtable;
        }
    }

    internal sealed unsafe class NonBlittableComWrappersMarshallerAttribute : WindowsRuntimeComWrappersMarshallerAttribute
    {
        public override void* GetOrCreateComInterfaceForObject(object value)
        {
            return WindowsRuntimeValueTypeMarshaller.BoxToUnmanaged<global::TestComponent.NonBlittable>((global::TestComponent.NonBlittable) value, in NonBlittableReferenceImpl.IID_IReferenceOfNonBlittable).DetachThisPtrUnsafe();
        }

        public override ComInterfaceEntry* ComputeVtables(out int count)
        {
            count = sizeof(NonBlittableInterfaceEntries) / sizeof(ComInterfaceEntry);
            return (ComInterfaceEntry*)Unsafe.AsPointer(in NonBlittableInterfaceEntriesImpl.Entries);
        }

        public override object CreateObject(void* value, out CreatedWrapperFlags wrapperFlags)
        {
            wrapperFlags = CreatedWrapperFlags.NonWrapping;
            return WindowsRuntimeValueTypeMarshaller.UnboxToManagedUnsafe<NonBlittable>(value, in NonBlittableReferenceImpl.IID_IReferenceOfNonBlittable);
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    file unsafe struct NonBlittableReferenceVftbl
    {
        public delegate* unmanaged[MemberFunction]<void*, Guid*, void**, int> QueryInterface;
        public delegate* unmanaged[MemberFunction]<void*, uint> AddRef;
        public delegate* unmanaged[MemberFunction]<void*, uint> Release;
        public delegate* unmanaged[MemberFunction]<void*, uint*, Guid**, int> GetIids;
        public delegate* unmanaged[MemberFunction]<void*, void**, int> GetRuntimeClassName;
        public delegate* unmanaged[MemberFunction]<void*, TrustLevel*, int> GetTrustLevel;
        public delegate* unmanaged[MemberFunction]<void*, NonBlittable*, int> get_Value;
    }

    file static unsafe class NonBlittableReferenceImpl
    {
        [FixedAddressValueType]
        private static readonly NonBlittableReferenceVftbl Vftbl;

        private const int S_OK = unchecked((int)0x00000000);
        private const int E_POINTER = unchecked((int)0x80004003);

        static NonBlittableReferenceImpl()
        {
            *(IInspectableVftbl*)Unsafe.AsPointer(ref Vftbl) = *(IInspectableVftbl*)IInspectableImpl.Vtable;
            Vftbl.get_Value = &get_Value;
        }

        public static nint Vtable
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (nint)Unsafe.AsPointer(in Vftbl);
        }

        [UnmanagedCallersOnly(CallConvs = [typeof(CallConvMemberFunction)])]
        public static int get_Value(void* thisPtr, NonBlittable* result)
        {
            if (result is null)
            {
                return E_POINTER;
            }

            try
            {
                *result = (NonBlittable)(ComInterfaceDispatch.GetInstance<object>((ComInterfaceDispatch*)thisPtr));
                return S_OK;
            }
            catch (Exception e)
            {
                return RestrictedErrorInfoExceptionMarshaller.ConvertToUnmanaged(e);
            }
        }

        public static ref readonly Guid IID_IReferenceOfNonBlittable
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                ReadOnlySpan<byte> data =
                [
                    0x3D, 0xFF, 0x2, 0xF7,
                    0xA, 0x8A,
                    0xCE, 0x59,
                    0xA7,
                    0xE,
                    0x4F,
                    0x2F,
                    0x13,
                    0x80,
                    0x63,
                    0x3
                ];
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference(data));
            }
        }
        
    }
}
#pragma warning restore CA1416
