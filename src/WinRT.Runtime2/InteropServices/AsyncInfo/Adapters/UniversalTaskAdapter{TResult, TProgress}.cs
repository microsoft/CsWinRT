// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;
using System.Threading;
using System.Threading.Tasks;
using Windows.Foundation;

#pragma warning disable IDE0270

namespace WindowsRuntime.InteropServices;

/// <summary>
/// Implements a wrapper that allows to expose managed <see cref="System.Threading.Tasks.Task"/> objects
/// to Windows Runtime consumers, via the projected <see cref="IAsyncInfo"/> interface.
/// </summary>
/// <typeparam name="TResult">The result type.</typeparam>
/// <typeparam name="TProgress">The type of progress information.</typeparam>
/// <typeparam name="TCompletedHandler">The type of completed handler (e.g. for <see cref="IAsyncAction.Completed"/>).</typeparam>
/// <typeparam name="TProgressHandler">The type of progress handler (e.g. for <see cref="IAsyncActionWithProgress{TProgress}.Progress"/>).</typeparam>
[SupportedOSPlatform("windows10.0.10240.0")]
internal abstract partial class UniversalTaskAdapter<
    TResult,
    TProgress,
    TCompletedHandler,
    TProgressHandler> : UniversalTaskAdapter,
    IAsyncInfo,
    IProgress<TProgress>
    where TCompletedHandler : class
    where TProgressHandler : class
{
    /// <summary>The token source used to cancel running operations.</summary>
    private volatile CancellationTokenSource? _cancelTokenSource;

    /// <summary>The async info's ID.</summary>
    /// <remarks>The <see cref="AsyncInfoIdGenerator.InvalidId"/> value stands for not yet been initialised.</remarks>
    private volatile uint _id = AsyncInfoIdGenerator.InvalidId;

    /// <summary>
    /// The cached error code used to avoid creating several exception objects
    /// if the <see cref="ErrorCode"/> property is accessed several times.
    /// </summary>
    /// <remarks>
    /// A <see langword="null"/> value indicates either no error or that <see cref="ErrorCode"/> has not yet been called.
    /// </remarks>
    private volatile Exception? _error;

    /// <summary>The state of the async info. Interlocked operations are used to manipulate this field.</summary>
    private volatile int _state = STATE_NOT_INITIALIZED;

    /// <summary>For IAsyncInfo instances that completed synchronously (at creation time) this field holds the result;
    /// for instances backed by an actual Task, this field holds a reference to the task generated by the task generator.
    /// Since we always know which of the above is the case, we can always cast this field to TResult in the former case
    /// or to one of Task or Task{TResult} in the latter case. This approach allows us to save a field on all IAsyncInfos.
    /// Notably, this makes us pay the added cost of boxing for synchronously completing IAsyncInfos where TResult is a
    /// value type, however, this is expected to occur rather rare compared to non-synchronously completed user-IAsyncInfos.
    /// </summary>
    private volatile object? _dataContainer;

    /// <summary>The registered completed handler.</summary>
    private volatile TCompletedHandler? _completedHandler;

    /// <summary>The registered progress handler.</summary>
    private volatile TProgressHandler? _progressHandler;

    /// <summary>
    /// Creates a new <see cref="UniversalTaskAdapter{TResult, TProgress, TCompletedHandler, TProgressHandler}"/> instance with the specified parameters.
    /// </summary>
    /// <param name="factory">The function to invoke to create the <see cref="Task"/> instance to wrap.</param>
    protected UniversalTaskAdapter(Delegate factory)
    {
        Debug.Assert(factory is
            Func<Task> or
            Func<CancellationToken, Task> or
            Func<IProgress<TProgress>, Task> or
            Func<CancellationToken, IProgress<TProgress>, Task>);

        // Construct task from the specified provider
        Task? task = InvokeTaskFactory(factory);

        if (task is null)
        {
            throw new NullReferenceException(SR.NullReference_TaskProviderReturnedNull);
        }

        if (task.Status == TaskStatus.Created)
        {
            throw new InvalidOperationException(SR.InvalidOperation_TaskProviderReturnedUnstartedTask);
        }

        _dataContainer = task;
        _state = STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED | STATE_STARTED;

        // Set the completion routine and let the task run
        _ = task.ContinueWith(
            continuationAction: static (_, @this) => Unsafe.As<UniversalTaskAdapter<TResult, TProgress, TCompletedHandler, TProgressHandler>>(@this!).TaskCompleted(),
            state: this,
            cancellationToken: CancellationToken.None,
            continuationOptions: TaskContinuationOptions.ExecuteSynchronously,
            scheduler: TaskScheduler.Default);
    }

    /// <summary>
    /// Creates a new <see cref="UniversalTaskAdapter{TResult, TProgress, TCompletedHandler, TProgressHandler}"/> instance with the specified parameters.
    /// </summary>
    /// <param name="task">The <see cref="Task"/> instance to wrap.</param>
    /// <param name="cancellationTokenSource">The <see cref="CancellationTokenSource"/> instance to use for cancellation.</param>
    /// <param name="progress">The <see cref="Progress{T}"/> instance to use to receive progress notifications from <paramref name="task"/>.</param>
    protected UniversalTaskAdapter(Task task, CancellationTokenSource? cancellationTokenSource, Progress<TProgress>? progress)
    {
        // Throw 'InvalidOperation' and not 'ArgumentException' for parity with the constructor that takes a factory
        if (task.Status == TaskStatus.Created)
        {
            throw new InvalidOperationException(SR.InvalidOperation_UnstartedTaskSpecified);
        }

        // We do not need to invoke any delegates to get the task, it is provided for us
        _dataContainer = task;

        // This must be the cancellation source for the token that the specified underlying task observes for cancellation.
        // It may also be 'null' in cases where the specified underlying task does not support cancellation.
        _cancelTokenSource = cancellationTokenSource;

        // If the specified underlying task reports progress, chain the reports to this async object's reporting method
        progress?.ProgressChanged += OnReportChainedProgress;

        _state = STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED | STATE_STARTED;

        // Set the completion routine and let the task run
        _ = task.ContinueWith(
            continuationAction: static (_, @this) => Unsafe.As<UniversalTaskAdapter<TResult, TProgress, TCompletedHandler, TProgressHandler>>(@this!).TaskCompleted(),
            state: this,
            cancellationToken: CancellationToken.None,
            continuationOptions: TaskContinuationOptions.ExecuteSynchronously,
            scheduler: TaskScheduler.Default);
    }


    /// <summary>
    /// Creates a new <see cref="UniversalTaskAdapter{TResult, TProgress, TCompletedHandler, TProgressHandler}"/> instance with the specified parameters.
    /// </summary>
    /// <param name="result">The result to wrap (which assumes the operation completed synchronously).</param>
    protected UniversalTaskAdapter(TResult result)
    {
        // Set the synchronous result
        _dataContainer = result;

        // Mark the task as completed successfully
        _state =
            STATEFLAG_COMPLETED_SYNCHRONOUSLY |
            STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET |
            STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED |
            STATE_RUN_TO_COMPLETION;
    }

    /// <summary>
    /// Creates a new <see cref="UniversalTaskAdapter{TResult, TProgress, TCompletedHandler, TProgressHandler}"/> instance with the specified parameters.
    /// </summary>
    /// <param name="_">The <see cref="CanceledTaskPlaceholder"/> value to select this overload.</param>
    protected UniversalTaskAdapter(CanceledTaskPlaceholder _)
    {
        _dataContainer = null;
        _error = null;

        // Mark the task as completed and canceled
        _state =
            STATEFLAG_COMPLETED_SYNCHRONOUSLY |
            STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET |
            STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED |
            STATE_CANCELLATION_COMPLETED;
    }

    /// <summary>
    /// Creates a new <see cref="UniversalTaskAdapter{TResult, TProgress, TCompletedHandler, TProgressHandler}"/> instance with the specified parameters.
    /// </summary>
    /// <param name="exception">The <see cref="Exception"/> to use to set the error state for the resulting instance.</param>
    protected UniversalTaskAdapter(Exception exception)
    {
        _dataContainer = null;
        _error = exception;

        // Mark the task as completed and in faulted state
        _state =
            STATEFLAG_COMPLETED_SYNCHRONOUSLY |
            STATEFLAG_MUST_RUN_COMPLETION_HNDL_WHEN_SET |
            STATEFLAG_COMPLETION_HNDL_NOT_YET_INVOKED |
            STATE_ERROR;
    }

    /// <summary>
    /// Finalizes the current instance.
    /// </summary>
    ~UniversalTaskAdapter()
    {
        TransitionToClosed();
    }

    /// <inheritdoc/>
    public sealed override Task? Task
    {
        get
        {
            EnsureNotClosed();

            return CompletedSynchronously ? null : (Task)_dataContainer;
        }
    }

    /// <inheritdoc/>
    void IProgress<TProgress>.Report(TProgress value)
    {
        ReportProgress(value);
    }
}