// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using WinRT.SourceGenerator;

namespace Generator
{
    [Generator]
    public class WinRTAotSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var properties = context.AnalyzerConfigOptionsProvider
                .Combine(context.CompilationProvider)
                .Select(static ((AnalyzerConfigOptionsProvider provider, Compilation compilation) value, CancellationToken _) => 
                    new CsWinRTAotOptimizerProperties(
                        value.provider.IsCsWinRTAotOptimizerEnabled(),
                        value.provider.IsCsWinRTComponent(),
                        value.provider.IsCsWinRTCcwLookupTableGeneratorEnabled(),
                        GeneratorExecutionContextHelper.IsCsWinRTAotOptimizerInAutoMode(value.provider, value.compilation))
                );

            var assemblyName = context.CompilationProvider.Select(static (compilation, _) => GeneratorHelper.EscapeAssemblyNameForIdentifier(compilation.AssemblyName));

            var propertiesAndAssemblyName = properties.Combine(assemblyName);

            var typeMapperAndProperties = context.AnalyzerConfigOptionsProvider
                .Select(static (options, ct) => options.GetCsWinRTUseWindowsUIXamlProjections())
                .Select(static (mode, ct) => new TypeMapper(mode))
                .Combine(properties);

            var vtablesToAddFromDetectedClassTypes = context.SyntaxProvider.CreateSyntaxProvider(
                    static (n, _) => NeedVtableAttribute(n),
                    static (n, _) => n)
                .Combine(typeMapperAndProperties)
                .Select(static ((GeneratorSyntaxContext generatorSyntaxContext, (TypeMapper typeMapper, CsWinRTAotOptimizerProperties properties) typeMapperAndProperties) value, CancellationToken _) => 
                        value.typeMapperAndProperties.properties.IsCsWinRTAotOptimizerInAutoMode ? 
                            GetVtableAttributeToAdd(value.generatorSyntaxContext, value.typeMapperAndProperties.typeMapper, false, value.typeMapperAndProperties.properties.IsCsWinRTCcwLookupTableGeneratorEnabled) : default)
                .Where(static vtableAttribute => vtableAttribute != default);

            var autoDetectedVtableAttributesToAdd = vtablesToAddFromDetectedClassTypes.Select(static (vtable, _) => vtable.Item1);
            var autoDetectedAdapterTypesToAddOnLookupTable = vtablesToAddFromDetectedClassTypes.SelectMany(static (vtable, _) => vtable.Item2);

            var vtablesToAddFromOptInClassTypes = context.SyntaxProvider.ForAttributeWithMetadataName(
                    "WinRT.GeneratedWinRTExposedTypeAttribute",
                    static (n, _) => NeedVtableAttribute(n),
                    static (n, _) => n)
                .Combine(typeMapperAndProperties)
                .Select(static ((GeneratorAttributeSyntaxContext generatorSyntaxContext, (TypeMapper typeMapper, CsWinRTAotOptimizerProperties properties) typeMapperAndProperties) value, CancellationToken _) =>
                        value.typeMapperAndProperties.properties.IsCsWinRTAotOptimizerEnabled ?
                            GetVtableAttributeToAdd(value.generatorSyntaxContext, value.typeMapperAndProperties.typeMapper, false, value.typeMapperAndProperties.properties.IsCsWinRTCcwLookupTableGeneratorEnabled) : default)
                .Where(static vtableAttribute => vtableAttribute != default);

            var optinVtableAttributesToAdd = vtablesToAddFromOptInClassTypes.Select(static (vtable, _) => vtable.Item1);
            var optinAdapterTypesToAddOnLookupTable = vtablesToAddFromOptInClassTypes.SelectMany(static (vtable, _) => vtable.Item2);

            // Merge both auto detected vtables and opt-in vtables.
            var vtableAttributesToAdd = autoDetectedVtableAttributesToAdd.Collect().Combine(optinVtableAttributesToAdd.Collect()).SelectMany(static (value, _) => value.Left.AddRange(value.Right).Distinct());
            context.RegisterImplementationSourceOutput(vtableAttributesToAdd.Collect().Combine(propertiesAndAssemblyName), GenerateVtableAttributes);

            // Get the vtables for component types.  This is used for filtering out generic interfaces
            // that will already be generated by the component generator.
            var vtablesFromComponentTypes = context.SyntaxProvider.CreateSyntaxProvider(
                    static (n, _) => IsComponentType(n),
                    static (n, _) => n)
                .Combine(typeMapperAndProperties)
                // Get component types if only authoring scenario and if aot optimizer enabled.
                .Select(static ((GeneratorSyntaxContext generatorSyntaxContext, (TypeMapper typeMapper, CsWinRTAotOptimizerProperties properties) typeMapperAndProperties) value, CancellationToken _) =>
                        value.typeMapperAndProperties.properties.IsCsWinRTAotOptimizerEnabled && value.typeMapperAndProperties.properties.IsCsWinRTComponent ? 
                            GetVtableAttributeToAdd(value.generatorSyntaxContext, value.typeMapperAndProperties.typeMapper, true, true) : default)
                .Where(static vtableAttribute => vtableAttribute != default);

            var autoDetectedInstantiatedTypesToAddOnLookupTable = context.SyntaxProvider.CreateSyntaxProvider(
                    static (n, _) => NeedVtableOnLookupTable(n),
                    static (n, _) => n)
                .Combine(typeMapperAndProperties)
                .Select(static ((GeneratorSyntaxContext generatorSyntaxContext, (TypeMapper typeMapper, CsWinRTAotOptimizerProperties properties) typeMapperAndProperties) value,
                                CancellationToken _) =>
                        value.typeMapperAndProperties.properties.IsCsWinRTAotOptimizerInAutoMode && value.typeMapperAndProperties.properties.IsCsWinRTCcwLookupTableGeneratorEnabled ? 
                            GetVtableAttributesToAddOnLookupTable(value.generatorSyntaxContext, value.typeMapperAndProperties.typeMapper, value.typeMapperAndProperties.properties.IsCsWinRTComponent) : 
                            (EquatableArray<VtableAttribute>)ImmutableArray<VtableAttribute>.Empty)
                .SelectMany(static (vtable, _) => vtable)
                .Where(static vtableAttribute => vtableAttribute != null);

            var optinInstantiatedTypesToAddOnLookupTable = context.SyntaxProvider.ForAttributeWithMetadataName(
                    "WinRT.GeneratedWinRTExposedExternalTypeAttribute",
                    static (n, _) => true,
                    static (n, _) => n)
                .Combine(typeMapperAndProperties)
                .Select(static ((GeneratorAttributeSyntaxContext generatorSyntaxContext, (TypeMapper typeMapper, CsWinRTAotOptimizerProperties properties) typeMapperAndProperties) value,
                                CancellationToken _) =>
                        value.typeMapperAndProperties.properties.IsCsWinRTAotOptimizerEnabled && value.typeMapperAndProperties.properties.IsCsWinRTCcwLookupTableGeneratorEnabled ?
                            GetVtableAttributesToAddOnLookupTable(value.generatorSyntaxContext, value.typeMapperAndProperties.typeMapper, value.typeMapperAndProperties.properties.IsCsWinRTComponent) :
                            (EquatableArray<VtableAttribute>)ImmutableArray<VtableAttribute>.Empty)
                .SelectMany(static (vtable, _) => vtable)
                .Where(static vtableAttribute => vtableAttribute != null);

            var instantiatedTaskAdapters = context.SyntaxProvider.CreateSyntaxProvider(
                    static (n, _) => IsAsyncOperationMethodCall(n),
                    static (n, _) => n)
                .Combine(typeMapperAndProperties)
                .Select(static ((GeneratorSyntaxContext generatorSyntaxContext, (TypeMapper typeMapper, CsWinRTAotOptimizerProperties properties) typeMapperAndProperties) value,
                                CancellationToken _) =>
                        value.typeMapperAndProperties.properties.IsCsWinRTAotOptimizerInAutoMode && value.typeMapperAndProperties.properties.IsCsWinRTCcwLookupTableGeneratorEnabled ?
                            GetVtableAttributesForTaskAdapters(value.generatorSyntaxContext, value.typeMapperAndProperties.typeMapper, value.typeMapperAndProperties.properties.IsCsWinRTComponent) : default)
                .Where(static vtableAttribute => vtableAttribute != default)
                .Collect();

            // Merge both adapter types lists and instantiated types lists.
            var vtablesToAddOnLookupTable = 
                autoDetectedInstantiatedTypesToAddOnLookupTable.Collect().
                Combine(autoDetectedAdapterTypesToAddOnLookupTable.Collect()).
                Combine(optinInstantiatedTypesToAddOnLookupTable.Collect()).
                Combine(optinAdapterTypesToAddOnLookupTable.Collect()).
                Combine(instantiatedTaskAdapters).
                SelectMany(static (value, _) => 
                    value.Left.Left.Left.Left
                    .AddRange(value.Left.Left.Left.Right)
                    .AddRange(value.Left.Left.Right)
                    .AddRange(value.Left.Right)
                    .AddRange(value.Right)
                    .Distinct()
                );

            var genericInterfacesFromVtableAttribute = vtableAttributesToAdd.Combine(properties).SelectMany(
                static ((VtableAttribute vtableAttribute, CsWinRTAotOptimizerProperties properties) value, CancellationToken _) =>
                    // If this is a CsWinRT component, the public types are handled by the component source generator rather than
                    // the AOT source generator.  So we filter those out here.
                    (!value.properties.IsCsWinRTComponent || (value.properties.IsCsWinRTComponent && !value.vtableAttribute.IsPublic)) ? 
                        value.vtableAttribute.GenericInterfaces : (EquatableArray<GenericInterface>)ImmutableArray<GenericInterface>.Empty).Collect();
            var genericInterfacesFromVtableLookupTable = vtablesToAddOnLookupTable.SelectMany(static (vtable, _) => vtable.GenericInterfaces).Collect();

            // The component generator generates vtable attributes for public types.  The generic interfaces used by those types or its adapter types
            // can overlap with the ones being generated here.  So get which ones are already generated to be able to filter them out.
            var genericInterfacesGeneratedByComponentGenerator = vtablesFromComponentTypes.
                SelectMany(static ((VtableAttribute vtableAttribute, EquatableArray<VtableAttribute> adapterTypes) classType, CancellationToken _) =>
                        classType.vtableAttribute.GenericInterfaces.Union(classType.adapterTypes.SelectMany(static v => v.GenericInterfaces)).Distinct()).
                Collect();

            context.RegisterImplementationSourceOutput(
                genericInterfacesFromVtableAttribute
                .Combine(genericInterfacesFromVtableLookupTable)
                .Combine(genericInterfacesGeneratedByComponentGenerator)
                .Combine(propertiesAndAssemblyName),
                GenerateCCWForGenericInstantiation);

            context.RegisterImplementationSourceOutput(vtablesToAddOnLookupTable.Collect().Combine(propertiesAndAssemblyName), GenerateVtableLookupTable);

            var bindableCustomPropertyAttributes = context.SyntaxProvider.ForAttributeWithMetadataName(
                    "WinRT.GeneratedBindableCustomPropertyAttribute",
                    static (n, _) => NeedCustomPropertyImplementation(n),
                    static (n, _) => n)
                .Combine(properties)
                .Select(static ((GeneratorAttributeSyntaxContext generatorSyntaxContext, CsWinRTAotOptimizerProperties properties) value, CancellationToken _) =>
                        value.properties.IsCsWinRTAotOptimizerEnabled ? GetBindableCustomProperties(value.generatorSyntaxContext) : default)
                .Where(static bindableCustomProperties => bindableCustomProperties != default)
                .Collect()
                .Combine(properties);
            context.RegisterImplementationSourceOutput(bindableCustomPropertyAttributes, GenerateBindableCustomProperties);
        }

        // Restrict to non-projected classes which can be instantiated
        // and are partial allowing to add attributes.
        private static bool NeedVtableAttribute(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax declaration &&
                !declaration.Modifiers.Any(static m => m.IsKind(SyntaxKind.StaticKeyword) || m.IsKind(SyntaxKind.AbstractKeyword)) &&
                GeneratorHelper.IsPartial(declaration) &&
                !GeneratorHelper.IsWinRTType(declaration); // Making sure it isn't an RCW we are projecting.
        }

        // Filters to non WinRT types which are public and can be instantiated.
        // This is used to try to determine types which a component source generator will process.
        private static bool IsComponentType(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax declaration &&
                !declaration.Modifiers.Any(static m => m.IsKind(SyntaxKind.StaticKeyword) || m.IsKind(SyntaxKind.AbstractKeyword)) &&
                declaration.Modifiers.Any(static m => m.IsKind(SyntaxKind.PublicKeyword)) &&
                !GeneratorHelper.IsWinRTType(declaration); // Making sure it isn't an RCW we are projecting.
        }

        private static bool NeedCustomPropertyImplementation(SyntaxNode node)
        {
            if ((node is ClassDeclarationSyntax classDeclaration && !classDeclaration.Modifiers.Any(static m => m.IsKind(SyntaxKind.StaticKeyword) || m.IsKind(SyntaxKind.AbstractKeyword))) ||
                (node is RecordDeclarationSyntax recordDeclaration && !recordDeclaration.Modifiers.Any(static m => m.IsKind(SyntaxKind.StaticKeyword) || m.IsKind(SyntaxKind.AbstractKeyword))) ||
                (node is StructDeclarationSyntax structDeclaration && !structDeclaration.Modifiers.Any(static m => m.IsKind(SyntaxKind.StaticKeyword))))
            {
                TypeDeclarationSyntax typeDeclaration = (TypeDeclarationSyntax)node;

                return GeneratorHelper.IsPartial(typeDeclaration);
            }

            return false;
        }

        private static (VtableAttribute, EquatableArray<VtableAttribute>) GetVtableAttributeToAdd(
            GeneratorSyntaxContext context,
            TypeMapper typeMapper,
            bool checkForComponentTypes,
            bool isCsWinRTCcwLookupTableGeneratorEnabled)
        {
            return GetVtableAttributeToAdd(
                context.SemanticModel.GetDeclaredSymbol(context.Node as ClassDeclarationSyntax),
                typeMapper,
                context.SemanticModel.Compilation,
                checkForComponentTypes,
                isCsWinRTCcwLookupTableGeneratorEnabled);
        }

        private static (VtableAttribute, EquatableArray<VtableAttribute>) GetVtableAttributeToAdd(
            GeneratorAttributeSyntaxContext context,
            TypeMapper typeMapper,
            bool checkForComponentTypes,
            bool isCsWinRTCcwLookupTableGeneratorEnabled)
        {
            return GetVtableAttributeToAdd(
                (ITypeSymbol)context.TargetSymbol,
                typeMapper,
                context.SemanticModel.Compilation,
                checkForComponentTypes,
                isCsWinRTCcwLookupTableGeneratorEnabled);
        }

        private static (VtableAttribute, EquatableArray<VtableAttribute>) GetVtableAttributeToAdd(
            ITypeSymbol symbol,
            TypeMapper typeMapper,
            Compilation compilation,
            bool checkForComponentTypes,
            bool isCsWinRTCcwLookupTableGeneratorEnabled)
        {
            var isWinRTTypeFunc = checkForComponentTypes ?
                GeneratorHelper.IsWinRTTypeWithPotentialAuthoringComponentTypesFunc(compilation) :
                GeneratorHelper.IsWinRTType;
            var vtableAttribute = GetVtableAttributeToAdd(symbol, isWinRTTypeFunc, typeMapper, compilation, false);
            if (vtableAttribute != default)
            {
                HashSet<VtableAttribute> vtableAttributesForLookupTable = [];
                // Add any adapter types which may be needed if certain functions
                // from some known interfaces are called.
                if (isCsWinRTCcwLookupTableGeneratorEnabled)
                {
                    AddVtableAdapterTypeForKnownInterface(symbol, compilation, isWinRTTypeFunc, typeMapper, vtableAttributesForLookupTable);
                }
                return (vtableAttribute, vtableAttributesForLookupTable.ToImmutableArray());
            }

            return default;
        }

        // There are several async operation related methods that can be called.
        // But they are all under the AsyncInfo static class or is the AsAsyncOperation
        // extension method.
        static bool IsAsyncOperationMethodCall(SyntaxNode node)        
        {
            if (node is InvocationExpressionSyntax methodInvoke &&
                methodInvoke.Expression is MemberAccessExpressionSyntax methodAccess)
            {
                // Check for static class as a way of handling all the async functions from it.
                if (methodAccess.Expression is IdentifierNameSyntax className && 
                    className.Identifier.ValueText == "AsyncInfo")
                {
                    return true;
                }

                // Check for calling the fully qualified static class.
                // i.e. System.Runtime.InteropServices.WindowsRuntime.AsyncInfo
                if (methodAccess.Expression is MemberAccessExpressionSyntax memberAccess &&
                    memberAccess.Name.Identifier.ValueText == "AsyncInfo")
                {
                    return true;
                }

                // Check for function call for the scenario that doesn't use the static class.
                if (methodAccess.Name is IdentifierNameSyntax methodName)
                {
                    return methodName.Identifier.ValueText == "AsAsyncOperation";
                }
            }

            return false;
        }

        // Detect if AsAsyncOperation or similar function is being called and if so,
        // make sure the generic adapter type we use for it is on the lookup table.
        // We do this both assuming this is not an authoring component and is an authoring
        // component as we don't know that at this stage and the results can vary based on that.
        // We will choose the right one later when we can combine with properties.
        private static VtableAttribute GetVtableAttributesForTaskAdapters(GeneratorSyntaxContext context, TypeMapper typeMapper, bool isCsWinRTComponent)
        {
            // Generic instantiation of task adapters make of use of unsafe.
            // This will be caught by GetVtableAttributeToAdd, but catching it early here too.
            if (!GeneratorHelper.AllowUnsafe(context.SemanticModel.Compilation))
            {
                return default;
            }

            if (context.SemanticModel.GetSymbolInfo(context.Node as InvocationExpressionSyntax).Symbol is IMethodSymbol symbol)
            {
                var adapterTypeStr = GeneratorHelper.GetTaskAdapterIfAsyncMethod(symbol);
                if (!string.IsNullOrEmpty(adapterTypeStr))
                {
                    var adpaterType = context.SemanticModel.Compilation.GetTypeByMetadataName(adapterTypeStr);
                    if (adpaterType is not null)
                    {
                        var constructedAdapterType = adpaterType.Construct([.. symbol.TypeArguments]);
                        return GetVtableAttributeToAdd(
                            constructedAdapterType,
                            !isCsWinRTComponent ? GeneratorHelper.IsWinRTType : GeneratorHelper.IsWinRTTypeWithPotentialAuthoringComponentTypesFunc(context.SemanticModel.Compilation),
                            typeMapper,
                            context.SemanticModel.Compilation,
                            false);
                    }
                }
            }

            return default;
        }

#nullable enable
        private static BindableCustomProperties GetBindableCustomProperties(GeneratorAttributeSyntaxContext context)
        {
            // We expect a class with a single attribute.
            var symbol = (INamedTypeSymbol)context.TargetSymbol;
            var attributeData = context.Attributes.First();

            List<BindableCustomProperty> bindableCustomProperties = new();

            // Make all public properties in the class bindable including ones in base type.
            if (attributeData.ConstructorArguments.Length == 0)
            {
                for (var curSymbol = symbol; curSymbol != null; curSymbol = curSymbol.BaseType)
                {
                    foreach (var propertySymbol in curSymbol.GetMembers().
                        Where(static m => m.Kind == SymbolKind.Property &&
                                     m.DeclaredAccessibility == Accessibility.Public))
                    {
                        AddProperty(propertySymbol);
                    }
                }
            }
            // Make specified public properties in the class bindable including ones in base type.
            else if (attributeData.ConstructorArguments is
                [
                    { Kind: TypedConstantKind.Array, Values: [..] propertyNames },
                    { Kind: TypedConstantKind.Array, Values: [..] propertyIndexerTypes }
                ])
            {
                for (var curSymbol = symbol; curSymbol != null; curSymbol = curSymbol.BaseType)
                {
                    foreach (var member in curSymbol.GetMembers())
                    {
                        if (member is IPropertySymbol propertySymbol &&
                            member.DeclaredAccessibility == Accessibility.Public)
                        {
                            if (!propertySymbol.IsIndexer &&
                                propertyNames.Any(p => p.Value is string value && value == propertySymbol.Name))
                            {
                                AddProperty(propertySymbol);
                            }
                            else if (propertySymbol.IsIndexer &&
                                     // ICustomProperty only supports single indexer parameter.
                                     propertySymbol.Parameters.Length == 1 &&
                                     propertyIndexerTypes.Any(p => p.Value is ISymbol typeSymbol && typeSymbol.Equals(propertySymbol.Parameters[0].Type, SymbolEqualityComparer.Default)))
                            {
                                AddProperty(propertySymbol);
                            }
                        }
                    }
                }
            }

            var typeName = ToFullyQualifiedString(symbol);
            bool isGlobalNamespace = symbol.ContainingNamespace == null || symbol.ContainingNamespace.IsGlobalNamespace;
            var @namespace = symbol.ContainingNamespace?.ToDisplayString();
            if (!isGlobalNamespace)
            {
                typeName = typeName[(@namespace!.Length + 1)..];
            }

            EquatableArray<TypeInfo> classHierarchy = ImmutableArray<TypeInfo>.Empty;

            // Gather the type hierarchy, only if the type is nested (as an optimization)
            if (symbol.ContainingType is not null)
            {
                List<TypeInfo> hierarchyList = new();

                for (ITypeSymbol parent = symbol; parent is not null; parent = parent.ContainingType)
                {
                    hierarchyList.Add(new TypeInfo(
                        parent.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
                        parent.TypeKind,
                        parent.IsRecord));
                }

                classHierarchy = ImmutableArray.CreateRange(hierarchyList);
            }

            return new BindableCustomProperties(
                @namespace,
                isGlobalNamespace,
                typeName,
                symbol.TypeKind,
                symbol.IsRecord,
                classHierarchy,
                ToFullyQualifiedString(symbol),
                bindableCustomProperties.ToImmutableArray());

            void AddProperty(ISymbol symbol)
            {
                if (symbol is IPropertySymbol propertySymbol)
                {
                    bindableCustomProperties.Add(new BindableCustomProperty(
                        propertySymbol.MetadataName,
                        ToFullyQualifiedString(propertySymbol.Type),
                        // Make sure the property accessors are also public even if property itself is public.
                        propertySymbol.GetMethod != null && propertySymbol.GetMethod.DeclaredAccessibility == Accessibility.Public,
                        propertySymbol.SetMethod != null && !propertySymbol.SetMethod.IsInitOnly && propertySymbol.SetMethod.DeclaredAccessibility == Accessibility.Public,
                        propertySymbol.IsIndexer,
                        propertySymbol.IsIndexer ? ToFullyQualifiedString(propertySymbol.Parameters[0].Type) : "",
                        propertySymbol.IsStatic
                        ));
                }
            }
        }
#nullable disable

        private static string ToFullyQualifiedString(ISymbol symbol)
        {
            // Used to ensure class names within generics are fully qualified to avoid
            // having issues when put in ABI namespaces.
            var symbolDisplayString = new SymbolDisplayFormat(
                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Included,
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.ExpandNullable);

            var qualifiedString = symbol.ToDisplayString(symbolDisplayString);
            return qualifiedString.StartsWith("global::") ? qualifiedString[8..] : qualifiedString;
        }

        private static string ToVtableLookupString(ISymbol symbol)
        {
            List<string> genericArguments = [];
            var fullName = ToVtableLookupString(symbol, genericArguments);
            if (genericArguments.Count == 0)
            {
                return fullName;
            }

            return $$"""{{fullName}}[{{string.Join(",", genericArguments)}}]""";
        }

        private static string ToVtableLookupString(ISymbol symbol, List<string> genericArguments, bool ignoreTypeArguments = false)
        {
            if (symbol is INamedTypeSymbol namedTypeSymbol &&
                !ignoreTypeArguments &&
                namedTypeSymbol.TypeArguments.Length != 0)
            {
                // Ignore type arguments and get the string representation for the rest of
                // the type to properly handle nested types.
                var fullName = ToVtableLookupString(symbol, genericArguments, true);
                // Type arguments are collected but not added to the type name until the end
                // per the format of Type.ToString().  ToVtableLookupString on the symbol is
                // also called first to ensure any type arguments from any nested parent types
                // are added first.
                foreach (var typeArgument in namedTypeSymbol.TypeArguments)
                {
                    genericArguments.Add(ToVtableLookupString(typeArgument));
                }
                return fullName;
            }
            else
            {
                // If it is a generic type argument or the type is directly under a namspace, we just use the ToDisplayString API.
                if (symbol is not INamedTypeSymbol || symbol.ContainingSymbol is INamespaceSymbol || symbol.ContainingSymbol is null)
                {
                    var arity = symbol is INamedTypeSymbol namedType && namedType.Arity > 0 ? "`" + namedType.Arity : "";
                    var symbolDisplayString = new SymbolDisplayFormat(
                        globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,
                        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.ExpandNullable);
                    return symbol.ToDisplayString(symbolDisplayString) + arity;
                }
                else
                {
                    // Nested types use + in the fully qualified name rather than .
                    return ToVtableLookupString(symbol.ContainingSymbol, genericArguments) + "+" + symbol.MetadataName;
                }
            }
        }

        private static string GetRuntimeClassName(
            INamedTypeSymbol type,
            Func<ISymbol, TypeMapper, bool> isWinRTType,
            TypeMapper mapper)
        {
            if (type == null)
            {
                return string.Empty;
            }

            string metadataName = string.Join(".", type.ContainingNamespace?.ToDisplayString(), type.MetadataName);
            if (type.IsGenericType && !type.IsDefinition)
            {
                StringBuilder builder = new();

                builder.Append(GetRuntimeClassName(type.OriginalDefinition, isWinRTType, mapper));
                builder.Append("<");

                bool first = true;
                foreach (var genericArg in type.TypeArguments)
                {
                    if (!first)
                    {
                        builder.Append(", ");
                    }

                    builder.Append(GetRuntimeClassName(genericArg as INamedTypeSymbol, isWinRTType, mapper));
                    first = false;
                }

                builder.Append(">");

                return builder.ToString();
            }
            else if (type.SpecialType == SpecialType.System_Object)
            {
                return "Object";
            }
            else if (type.SpecialType == SpecialType.System_Byte)
            {
                return "UInt8";
            }
            else if (type.SpecialType == SpecialType.System_SByte)
            {
                return "Int8";
            }
            else if (mapper.HasMappingForType(metadataName))
            {
                var mapping = mapper.GetMappedType(metadataName).GetMapping();
                return mapping.Item1 + "." + mapping.Item2;
            }
            else if (type.SpecialType != SpecialType.None)
            {
                return type.Name;
            }
            else if (isWinRTType(type, mapper))
            {
                return metadataName;
            }
            else
            {
                // If we end up here, this is most likely an authoring scenario where the type is being authored
                // for WinRT projection in this component.
                return metadataName;
            }
        }

        internal static VtableAttribute GetVtableAttributeToAdd(
            ITypeSymbol symbol, 
            Func<ISymbol, TypeMapper, bool> isWinRTType, 
            TypeMapper mapper,
            Compilation compilation,
            bool isAuthoring, 
            string authoringDefaultInterface = "")
        {
            if (symbol is null)
            {
                return default;
            }

            if (GeneratorHelper.HasNonInstantiatedWinRTGeneric(symbol, mapper))
            {
                return default;
            }

            HashSet<string> interfacesToAddToVtable = new();
            HashSet<GenericInterface> genericInterfacesToAddToVtable = new();

            if (!string.IsNullOrEmpty(authoringDefaultInterface))
            {
                interfacesToAddToVtable.Add(authoringDefaultInterface);
            }

            // If the attribute is already placed on the type, don't generate a new one as we will
            // use the specified one.  Also for authoring scenarios where we call this for authored WinRT types,
            // don't generate the runtimeclass name for them as we will rely on the full name for them as we do today.
            var checkForRuntimeClasName = !GeneratorHelper.HasWinRTRuntimeClassNameAttribute(symbol, compilation) && 
                (!isAuthoring || (isAuthoring && !isWinRTType(symbol, mapper)));
            INamedTypeSymbol interfaceToUseForRuntimeClassName = null;
            foreach (var iface in symbol.AllInterfaces)
            {
                if (isWinRTType(iface, mapper))
                {
                    // If the interface projection was generated using an older CsWinRT version,
                    // it won't have the necessary properties to generate the AOT compatible code
                    // and we don't want to result in compiler errors.
                    // We exclude generic types as they are either defined in WinRT.Runtime or the
                    // Windows SDK projection, so we don't need to check them.
                    if (!iface.IsGenericType && 
                        GeneratorHelper.IsOldProjectionAssembly(iface.ContainingAssembly))
                    {
                        return default;
                    }

                    interfacesToAddToVtable.Add(ToFullyQualifiedString(iface));
                    AddGenericInterfaceInstantiation(iface);
                    CheckForInterfaceToUseForRuntimeClassName(iface);
                }

                if (iface.IsGenericType && TryGetCompatibleWindowsRuntimeTypesForVariantType(iface, mapper, null, isWinRTType, out var compatibleIfaces))
                {
                    foreach (var compatibleIface in compatibleIfaces)
                    {
                        // For covariant interfaces which are exclusive interfaces that the projection implemented
                        // such as overrides / protected interfaces in composable types, we don't include them in
                        // the vtable as they are today marked internal and we can't reference them due to that.
                        // If this scenarios matters where native callers do indeed QI for these exclusive
                        // covariant interfaces, we can in the future project them as public, but for now
                        // leaving as is.
                        if (GeneratorHelper.IsInternalInterfaceFromReferences(compatibleIface, compilation.Assembly))
                        {
                            continue;
                        }

                        interfacesToAddToVtable.Add(ToFullyQualifiedString(compatibleIface));
                        AddGenericInterfaceInstantiation(compatibleIface);
                        CheckForInterfaceToUseForRuntimeClassName(compatibleIface);
                    }
                }
            }

            // KeyValueType is a value type in C#, but it is projected as a reference type in WinRT. 
            if (symbol.TypeKind == TypeKind.Struct && symbol.MetadataName == "KeyValuePair`2" && isWinRTType(symbol, mapper))
            {
                interfacesToAddToVtable.Add(ToFullyQualifiedString(symbol));
                AddGenericInterfaceInstantiation(symbol as INamedTypeSymbol);

                // KeyValuePair is projected as an interface.
                CheckForInterfaceToUseForRuntimeClassName(symbol as INamedTypeSymbol);
            }

            bool isDelegate = false;
            if (symbol.TypeKind == TypeKind.Delegate)
            {
                isDelegate = true;
                interfacesToAddToVtable.Add(ToFullyQualifiedString(symbol));
                AddGenericInterfaceInstantiation(symbol as INamedTypeSymbol);
            }

            if (!interfacesToAddToVtable.Any())
            {
                return default;
            }

            // If there are generic interfaces, the generic interface instantiations make use of
            // unsafe. But if it isn't enabled, we don't want to fail to compile in case it is
            // not a WinRT scenario. So we instead, don't generate the code that needs the unsafe
            // and there would be a diagnostic produced by the analyzer.
            if (genericInterfacesToAddToVtable.Any() && !GeneratorHelper.AllowUnsafe(compilation))
            {
                return default;
            }

            var typeName = ToFullyQualifiedString(symbol);
            bool isGlobalNamespace = symbol.ContainingNamespace == null || symbol.ContainingNamespace.IsGlobalNamespace;
            var @namespace = symbol.ContainingNamespace?.ToDisplayString();
            if (!isGlobalNamespace)
            {
                typeName = typeName[(@namespace.Length + 1)..];
            }

            EquatableArray<TypeInfo> classHierarchy = ImmutableArray<TypeInfo>.Empty;

            // Gather the type hierarchy, only if the type is nested (as an optimization)
            if (symbol.ContainingType is not null)
            {
                List<TypeInfo> hierarchyList = new();

                for (ITypeSymbol parent = symbol; parent is not null; parent = parent.ContainingType)
                {
                    hierarchyList.Add(new TypeInfo(
                        parent.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
                        parent.TypeKind,
                        parent.IsRecord));
                }

                classHierarchy = ImmutableArray.CreateRange(hierarchyList);
            }

            return new VtableAttribute(
                isAuthoring ? "ABI.Impl." + @namespace : @namespace,
                isGlobalNamespace,
                typeName,
                classHierarchy,
                ToVtableLookupString(symbol),
                interfacesToAddToVtable.ToImmutableArray(),
                genericInterfacesToAddToVtable.ToImmutableArray(),
                symbol is IArrayTypeSymbol,
                isDelegate,
                symbol.DeclaredAccessibility == Accessibility.Public,
                GetRuntimeClassName(interfaceToUseForRuntimeClassName, isWinRTType, mapper));

            void AddGenericInterfaceInstantiation(INamedTypeSymbol iface)
            {
                if (iface.IsGenericType)
                {
                    List<GenericParameter> genericParameters = new();
                    foreach (var genericParameter in iface.TypeArguments)
                    {
                        var isNullable = genericParameter.IsValueType && genericParameter.NullableAnnotation.HasFlag(NullableAnnotation.Annotated);

                        // Handle initialization of nested generics as they may not be
                        // initialized already.
                        if (!isNullable &&
                            genericParameter is INamedTypeSymbol genericParameterIface && 
                            genericParameterIface.IsGenericType)
                        {
                            AddGenericInterfaceInstantiation(genericParameterIface);
                        }

                        genericParameters.Add(new GenericParameter(
                            ToFullyQualifiedString(genericParameter),
                            GeneratorHelper.GetAbiType(genericParameter, mapper),
                            isNullable ? TypeKind.Interface : genericParameter.TypeKind));
                    }

                    genericInterfacesToAddToVtable.Add(new GenericInterface(
                        ToFullyQualifiedString(iface),
                        $$"""{{iface.ContainingNamespace}}.{{iface.MetadataName}}""",
                        genericParameters.ToImmutableArray()));
                }
            }

            bool IsExternalInternalInterface(INamedTypeSymbol iface)
            {
                return (iface.DeclaredAccessibility == Accessibility.Internal && !SymbolEqualityComparer.Default.Equals(iface.ContainingAssembly, compilation.Assembly)) || 
                    (iface.IsGenericType && iface.TypeArguments.Any(typeArgument => IsExternalInternalInterface(typeArgument as INamedTypeSymbol)));
            }

            // Determines the interface to use to represent the type when GetRuntimeClassName is called.
            // Given these are non WinRT types implementing WinRT interfaces, we find the most derived
            // interface to represent it so that it applies for most scenarios.
            void CheckForInterfaceToUseForRuntimeClassName(INamedTypeSymbol iface)
            {
                if (!checkForRuntimeClasName)
                {
                    return;
                }

                if (interfaceToUseForRuntimeClassName is null || compilation.HasImplicitConversion(iface, interfaceToUseForRuntimeClassName))
                {
                    interfaceToUseForRuntimeClassName = iface;
                }
            }
        }

        private static bool TryGetCompatibleWindowsRuntimeTypesForVariantType(INamedTypeSymbol type, TypeMapper mapper, Stack<INamedTypeSymbol> typeStack, Func<ISymbol, TypeMapper, bool> isWinRTType, out IList<INamedTypeSymbol> compatibleTypes)
        {
            compatibleTypes = null;

            // Out of all the C# interfaces which are valid WinRT interfaces and
            // support covariance, they all only have one generic parameter,
            // so scoping to only handle that.
            if (type is not { IsGenericType: true, TypeParameters: [{ Variance: VarianceKind.Out, IsValueType: false }] })
            {
                return false;
            }

            var definition = type.OriginalDefinition;
            if (!isWinRTType(definition, mapper))
            {
                return false;
            }

            if (typeStack == null)
            {
                typeStack = new Stack<INamedTypeSymbol>();
            }
            else
            {
                if (typeStack.Contains(type))
                {
                    return false;
                }
            }
            typeStack.Push(type);

            HashSet<ITypeSymbol> compatibleTypesForGeneric = new(SymbolEqualityComparer.Default);

            if (isWinRTType(type.TypeArguments[0], mapper))
            {
                compatibleTypesForGeneric.Add(type.TypeArguments[0]);
            }

            foreach (var iface in type.TypeArguments[0].AllInterfaces)
            {
                if (isWinRTType(iface, mapper))
                {
                    compatibleTypesForGeneric.Add(iface);
                }

                if (iface.IsGenericType
                    && TryGetCompatibleWindowsRuntimeTypesForVariantType(iface, mapper, typeStack, isWinRTType, out var compatibleIfaces))
                {
                    compatibleTypesForGeneric.UnionWith(compatibleIfaces);
                }
            }

            var baseType = type.TypeArguments[0].BaseType;
            while (baseType != null)
            {
                if (isWinRTType(baseType, mapper))
                {
                    compatibleTypesForGeneric.Add(baseType);
                }
                baseType = baseType.BaseType;
            }

            typeStack.Pop();

            compatibleTypes = new List<INamedTypeSymbol>(compatibleTypesForGeneric.Count);
            foreach (var compatibleType in compatibleTypesForGeneric)
            {
                compatibleTypes.Add(definition.Construct(compatibleType));
            }

            return true;
        }

        private static void GenerateVtableAttributes(
            SourceProductionContext sourceProductionContext,
            (ImmutableArray<VtableAttribute> vtableAttributes, (CsWinRTAotOptimizerProperties properties, string escapedAssemblyName) context) value)
        {
            if (!value.context.properties.IsCsWinRTAotOptimizerEnabled)
            {
                return;
            }

            GenerateVtableAttributes(sourceProductionContext.AddSource, value.vtableAttributes, value.context.properties.IsCsWinRTComponent, value.context.escapedAssemblyName);
        }

        internal static string GenerateVtableEntry(VtableEntry vtableEntry, string escapedAssemblyName)
        {
            StringBuilder source = new();

            foreach (var genericInterface in vtableEntry.GenericInterfaces)
            {
                source.AppendLine(GenericVtableInitializerStrings.GetInstantiationInitFunction(
                    genericInterface.GenericDefinition,
                    genericInterface.GenericParameters,
                    escapedAssemblyName));
            }

            if (vtableEntry.IsDelegate)
            {
                var @interface = vtableEntry.Interfaces.First();
                source.AppendLine();
                source.AppendLine($$"""
                                var delegateInterface = new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry
                                {
                                    IID = global::ABI.{{@interface}}.IID,
                                    Vtable = global::ABI.{{@interface}}.AbiToProjectionVftablePtr
                                };

                                return global::WinRT.DelegateTypeDetails<{{@interface}}>.GetExposedInterfaces(delegateInterface);
                        """);
            }
            else if (vtableEntry.Interfaces.Any())
            {
                source.AppendLine();
                source.AppendLine($$"""
                                return new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry[]
                                {
                        """);

                foreach (var @interface in vtableEntry.Interfaces)
                {
                    var genericStartIdx = @interface.IndexOf('<');
                    var interfaceStaticsMethod = @interface[..(genericStartIdx == -1 ? @interface.Length : genericStartIdx)] + "Methods";
                    if (genericStartIdx != -1)
                    {
                        interfaceStaticsMethod += @interface[genericStartIdx..@interface.Length];
                    }

                    source.AppendLine($$"""
                                                new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry
                                                {
                                                    IID = global::ABI.{{interfaceStaticsMethod}}.IID,
                                                    Vtable = global::ABI.{{interfaceStaticsMethod}}.AbiToProjectionVftablePtr
                                                },
                                    """);
                }
                source.AppendLine($$"""
                                };
                                """);
            }
            else
            {
                source.AppendLine($$"""
                                        return global::System.Array.Empty<global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry>();
                                """);
            }

            return source.ToString();
        }

        internal static void GenerateVtableAttributes(Action<string, string> addSource, ImmutableArray<VtableAttribute> vtableAttributes, bool isCsWinRTComponentFromAotOptimizer, string escapedAssemblyName)
        {
            var vtableEntryToVtableClassName = new Dictionary<VtableEntry, string>();
            StringBuilder vtableClassesSource = new();
            bool firstVtableClass = true;

            // Using ToImmutableHashSet to avoid duplicate entries from the use of partial classes by the developer
            // to split out their implementation.  When they do that, we will get multiple entries here for that
            // and try to generate the same attribute and file with the same data as we use the semantic model
            // to get all the symbol data rather than the data at an instance of a partial class definition.
            foreach (var vtableAttribute in vtableAttributes.ToImmutableHashSet())
            {
                // If this is a WinRT component project and this call is coming
                // from the AOT optimizer, then any public types are not handled
                // right now as they are handled by the WinRT component source generator
                // calling this.
                if (((isCsWinRTComponentFromAotOptimizer && !vtableAttribute.IsPublic) || !isCsWinRTComponentFromAotOptimizer) &&
                    vtableAttribute.Interfaces.Any())
                {
                    StringBuilder source = new();
                    if (!vtableAttribute.IsGlobalNamespace)
                    {
                        source.AppendLine($$"""
                        namespace {{vtableAttribute.Namespace}}
                        {
                        """);
                    }

                    // Check if this class shares the same vtable as another class.  If so, reuse the same generated class for it.
                    VtableEntry entry = new(vtableAttribute.Interfaces, vtableAttribute.GenericInterfaces, vtableAttribute.IsDelegate);
                    bool vtableEntryExists = vtableEntryToVtableClassName.TryGetValue(entry, out var ccwClassName);
                    if (!vtableEntryExists)
                    {
                        var @namespace = vtableAttribute.IsGlobalNamespace ? "" : $"{vtableAttribute.Namespace}.";
                        ccwClassName = GeneratorHelper.EscapeTypeNameForIdentifier(@namespace + vtableAttribute.ClassName);
                        vtableEntryToVtableClassName.Add(entry, ccwClassName);
                    }

                    var escapedClassName = GeneratorHelper.EscapeTypeNameForIdentifier(vtableAttribute.ClassName);

                    // Simple case when the type is not nested
                    if (vtableAttribute.ClassHierarchy.IsEmpty)
                    {
                        if (!string.IsNullOrEmpty(vtableAttribute.RuntimeClassName))
                        {
                            source.AppendLine($$"""[global::WinRT.WinRTRuntimeClassName("{{vtableAttribute.RuntimeClassName}}")]""");
                        }

                        source.AppendLine($$"""
                            [global::WinRT.WinRTExposedType(typeof(global::WinRT.{{escapedAssemblyName}}VtableClasses.{{ccwClassName}}WinRTTypeDetails))]
                            partial class {{vtableAttribute.ClassName}}
                            {
                            }
                            """);
                    }
                    else
                    {
                        ReadOnlySpan<TypeInfo> classHierarchy = vtableAttribute.ClassHierarchy.AsSpan();

                        // If the type is nested, correctly nest the type definition
                        for (int i = classHierarchy.Length - 1; i > 0; i--)
                        {
                            source.AppendLine($$"""
                                partial {{classHierarchy[i].GetTypeKeyword()}} {{classHierarchy[i].QualifiedName}}
                                {
                                """);
                        }

                        // Define the inner-most item with the attribute
                        if (!string.IsNullOrEmpty(vtableAttribute.RuntimeClassName))
                        {
                            source.AppendLine($$"""[global::WinRT.WinRTRuntimeClassName("{{vtableAttribute.RuntimeClassName}}")]""");
                        }

                        source.AppendLine($$"""
                            [global::WinRT.WinRTExposedType(typeof(global::WinRT.{{escapedAssemblyName}}VtableClasses.{{ccwClassName}}WinRTTypeDetails))]
                            partial {{classHierarchy[0].GetTypeKeyword()}} {{classHierarchy[0].QualifiedName}}
                            {
                            }
                            """);

                        // Close all brackets
                        for (int i = classHierarchy.Length - 1; i > 0; i--)
                        {
                            source.AppendLine("}");
                        }
                    }

                    // Only generate class, if this is the first time we run into this set of vtables.
                    if (!vtableEntryExists)
                    {
                        if (firstVtableClass)
                        {
                            vtableClassesSource.AppendLine($$""" 
                            namespace WinRT.{{escapedAssemblyName}}VtableClasses
                            {
                            """);
                            firstVtableClass = false;
                        }
                        else
                        {
                            vtableClassesSource.AppendLine();
                        }

                        vtableClassesSource.AppendLine($$"""
                    internal sealed class {{ccwClassName}}WinRTTypeDetails : global::WinRT.IWinRTExposedTypeDetails
                    {
                        public global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry[] GetExposedInterfaces()
                        {
                    """);

                        if (vtableAttribute.Interfaces.Any())
                        {
                            foreach (var genericInterface in vtableAttribute.GenericInterfaces)
                            {
                                vtableClassesSource.AppendLine(GenericVtableInitializerStrings.GetInstantiationInitFunction(
                                    genericInterface.GenericDefinition,
                                    genericInterface.GenericParameters,
                                    escapedAssemblyName));
                            }

                            vtableClassesSource.AppendLine();
                            vtableClassesSource.AppendLine($$"""
                                return new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry[]
                                {
                        """);

                            foreach (var @interface in vtableAttribute.Interfaces)
                            {
                                var genericStartIdx = @interface.IndexOf('<');
                                var interfaceStaticsMethod = @interface[..(genericStartIdx == -1 ? @interface.Length : genericStartIdx)] + "Methods";
                                if (genericStartIdx != -1)
                                {
                                    interfaceStaticsMethod += @interface[genericStartIdx..@interface.Length];
                                }

                                vtableClassesSource.AppendLine($$"""
                                                new global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry
                                                {
                                                    IID = global::ABI.{{interfaceStaticsMethod}}.IID,
                                                    Vtable = global::ABI.{{interfaceStaticsMethod}}.AbiToProjectionVftablePtr
                                                },
                                    """);
                            }
                            vtableClassesSource.AppendLine($$"""
                                };
                                """);
                        }
                        else
                        {
                            vtableClassesSource.AppendLine($$"""
                                        return global::System.Array.Empty<global::System.Runtime.InteropServices.ComWrappers.ComInterfaceEntry>();
                                """);
                        }

                        vtableClassesSource.AppendLine($$"""
                                }
                            }
                        """);
                    }

                    if (!vtableAttribute.IsGlobalNamespace)
                    {
                        source.AppendLine($@"}}");
                    }

                    string prefix = vtableAttribute.IsGlobalNamespace ? "" : $"{vtableAttribute.Namespace}.";
                    addSource($"{prefix}{escapedClassName}.WinRTVtable.g.cs", source.ToString());
                }
            }

            if (vtableClassesSource.Length != 0)
            {
                vtableClassesSource.AppendLine("}");
                addSource($"WinRTCCWVtable.g.cs", vtableClassesSource.ToString());
            }
        }

        private static void GenerateCCWForGenericInstantiation(
            SourceProductionContext sourceProductionContext, 
            (((ImmutableArray<GenericInterface> vtableAttributeList, ImmutableArray<GenericInterface> lookupTableList) interfacesToGenerate,
                ImmutableArray<GenericInterface> componentGeneratorList) genericInterfaces,
            (CsWinRTAotOptimizerProperties properties, string escapedAssemblyName) context) value)
        {
            if (!value.context.properties.IsCsWinRTAotOptimizerEnabled)
            {
                return;
            }

            HashSet<GenericInterface> genericInterfacesHashSet = new(value.genericInterfaces.interfacesToGenerate.vtableAttributeList);
            if (value.context.properties.IsCsWinRTCcwLookupTableGeneratorEnabled)
            {
                genericInterfacesHashSet.UnionWith(value.genericInterfaces.interfacesToGenerate.lookupTableList);
            }

            // Remove all the generic interfaces that are beign generated by the component generator.
            foreach (var i in value.genericInterfaces.componentGeneratorList)
            {
                genericInterfacesHashSet.Remove(i);
            }

            GenerateCCWForGenericInstantiation(sourceProductionContext.AddSource, genericInterfacesHashSet.ToImmutableArray(), value.context.escapedAssemblyName);
        }

        internal static void GenerateCCWForGenericInstantiation(Action<string, string> addSource, ImmutableArray<GenericInterface> genericInterfaces, string escapedAssemblyName)
        {
            StringBuilder source = new();

            if (genericInterfaces.Any())
            {
                source.AppendLine($$"""
                                    using System;
                                    using System.Runtime.InteropServices;
                                    using System.Runtime.CompilerServices;

                                    namespace WinRT.{{escapedAssemblyName}}GenericHelpers
                                    {
                                    """);
            }

            var updatedGenericInterfaces = GenericVtableInitializerStrings.AddDependentGenericInterfaces(genericInterfaces.ToImmutableHashSet());
            foreach (var genericInterface in updatedGenericInterfaces)
            {
                source.AppendLine();
                source.AppendLine("// " + genericInterface.Interface);
                source.AppendLine(GenericVtableInitializerStrings.GetInstantiation(
                    genericInterface.GenericDefinition,
                    genericInterface.GenericParameters));
            }

            if (genericInterfaces.Any())
            {
                source.AppendLine("}");
                addSource($"WinRTGenericInstantiation.g.cs", source.ToString());
            }
        }

        private static bool NeedVtableOnLookupTable(SyntaxNode node)
        {
            return (node is InvocationExpressionSyntax invocation && invocation.ArgumentList.Arguments.Count != 0) ||
                    node is AssignmentExpressionSyntax ||
                    node is VariableDeclarationSyntax ||
                    node is PropertyDeclarationSyntax ||
                    node is ReturnStatementSyntax;
        }

        private static EquatableArray<VtableAttribute> GetVtableAttributesToAddOnLookupTable(
            GeneratorSyntaxContext context,
            TypeMapper typeMapper,
            bool isCsWinRTComponent)
        {
            return GetVtableAttributesToAddOnLookupTable(
                    context,
                    typeMapper,
                    !isCsWinRTComponent ? GeneratorHelper.IsWinRTType : GeneratorHelper.IsWinRTTypeWithPotentialAuthoringComponentTypesFunc(context.SemanticModel.Compilation),
                    GeneratorHelper.IsWinRTClass(context.SemanticModel.Compilation));
        }

        private static EquatableArray<VtableAttribute> GetVtableAttributesToAddOnLookupTable(
            GeneratorSyntaxContext context,
            TypeMapper typeMapper,
            Func<ISymbol, TypeMapper, bool> isWinRTType,
            Func<ISymbol, bool> isWinRTClass)
        {
            HashSet<ITypeSymbol> visitedTypes = new(SymbolEqualityComparer.Default);
            HashSet<VtableAttribute> vtableAttributes = new();

            if (context.Node is InvocationExpressionSyntax invocation)
            {
                var invocationSymbol = context.SemanticModel.GetSymbolInfo(invocation).Symbol;
                if (invocationSymbol is IMethodSymbol methodSymbol &&
                    // Filter checks for boxing and casts to ones calling CsWinRT projected functions and
                    // functions within same assembly.  Functions within same assembly can take a boxed value
                    // and end up calling a projection function (i.e. ones generated by XAML compiler)
                    // In theory, another library can also be called which can call a projected function
                    // but not handling those scenarios for now.
                    (isWinRTClass(methodSymbol.ContainingSymbol) ||
                     SymbolEqualityComparer.Default.Equals(methodSymbol.ContainingAssembly, context.SemanticModel.Compilation.Assembly)))
                {
                    // Get the concrete types directly from the argument rather than
                    // using what the method accepts, which might just be an interface, so
                    // that we can try to include any other WinRT interfaces implemented by
                    // that type on the CCW when it is marshaled.
                    for (int idx = 0, paramsIdx = 0; idx < invocation.ArgumentList.Arguments.Count; idx++)
                    {
                        if (methodSymbol.Parameters[paramsIdx].RefKind != RefKind.Out)
                        {
                            var argumentType = context.SemanticModel.GetTypeInfo(invocation.ArgumentList.Arguments[idx].Expression);
                            AddVtableAttributesForType(argumentType, methodSymbol.Parameters[paramsIdx].Type);
                        }

                        // The method parameter can be declared as params which means
                        // an array of arguments can be passed for it and it is the
                        // last argument.
                        if (!methodSymbol.Parameters[paramsIdx].IsParams)
                        {
                            paramsIdx++;
                        }
                    }
                }
            }
            else if (context.Node is AssignmentExpressionSyntax assignment)
            {
                var leftSymbol = context.SemanticModel.GetSymbolInfo(assignment.Left).Symbol;
                if (leftSymbol is IPropertySymbol propertySymbol &&
                    (isWinRTClass(propertySymbol.ContainingSymbol) ||
                     SymbolEqualityComparer.Default.Equals(propertySymbol.ContainingAssembly, context.SemanticModel.Compilation.Assembly)))
                {
                    AddVtableAttributesForType(context.SemanticModel.GetTypeInfo(assignment.Right), propertySymbol.Type);
                }
                else if (leftSymbol is IFieldSymbol fieldSymbol &&
                    (isWinRTClass(fieldSymbol.ContainingSymbol) || 
                     SymbolEqualityComparer.Default.Equals(fieldSymbol.ContainingAssembly, context.SemanticModel.Compilation.Assembly)))
                {
                    AddVtableAttributesForType(context.SemanticModel.GetTypeInfo(assignment.Right), fieldSymbol.Type);
                }
            }
            // Detect scenarios where the variable declaration is to a boxed or cast type during initialization.
            else if (context.Node is VariableDeclarationSyntax variableDeclaration)
            {
                var leftSymbol = context.SemanticModel.GetSymbolInfo(variableDeclaration.Type).Symbol;
                if (leftSymbol is INamedTypeSymbol namedType)
                {
                    foreach (var variable in variableDeclaration.Variables)
                    {
                        if (variable.Initializer != null)
                        {
                            var instantiatedType = context.SemanticModel.GetTypeInfo(variable.Initializer.Value);
                            AddVtableAttributesForType(instantiatedType, namedType);
                        }
                    }
                }
            }
            // Detect scenarios where the property declaration has an initializer and is to a boxed or cast type during initialization.
            else if (context.Node is PropertyDeclarationSyntax propertyDeclaration)
            {
                if (propertyDeclaration.Initializer != null)
                {
                    var leftSymbol = context.SemanticModel.GetSymbolInfo(propertyDeclaration.Type).Symbol;
                    if (leftSymbol is INamedTypeSymbol namedType)
                    {
                        var instantiatedType = context.SemanticModel.GetTypeInfo(propertyDeclaration.Initializer.Value);
                        AddVtableAttributesForType(instantiatedType, namedType);
                    }
                }
                else if (propertyDeclaration.ExpressionBody != null)
                {
                    var leftSymbol = context.SemanticModel.GetSymbolInfo(propertyDeclaration.Type).Symbol;
                    if (leftSymbol is INamedTypeSymbol namedType)
                    {
                        var instantiatedType = context.SemanticModel.GetTypeInfo(propertyDeclaration.ExpressionBody.Expression);
                        AddVtableAttributesForType(instantiatedType, namedType);
                    }
                }
            }
            // Detect scenarios where the method or property being returned from is doing a box or cast of the type
            // in the return statement.
            else if (context.Node is ReturnStatementSyntax returnDeclaration && returnDeclaration.Expression is not null)
            {
                var returnSymbol = context.SemanticModel.GetTypeInfo(returnDeclaration.Expression);
                var parent = returnDeclaration.Ancestors().OfType<MemberDeclarationSyntax>().FirstOrDefault();
                if (parent is MethodDeclarationSyntax methodDeclaration)
                {
                    var methodReturnSymbol = context.SemanticModel.GetSymbolInfo(methodDeclaration.ReturnType).Symbol;
                    if (methodReturnSymbol is ITypeSymbol typeSymbol)
                    {
                        AddVtableAttributesForType(returnSymbol, typeSymbol);
                    }
                }
                else if (parent is BasePropertyDeclarationSyntax propertyDeclarationSyntax)
                {
                    var propertyTypeSymbol = context.SemanticModel.GetSymbolInfo(propertyDeclarationSyntax.Type).Symbol;
                    if (propertyTypeSymbol is ITypeSymbol typeSymbol)
                    {
                        AddVtableAttributesForType(returnSymbol, typeSymbol);
                    }
                }
            }

            return vtableAttributes.ToImmutableArray();

            // This handles adding vtable information for types for which we can not directly put an attribute on them.
            // This includes generic types that are boxed and and non-WinRT types for which our AOT source generator hasn't
            // ran on but implements WinRT interfaces.
            void AddVtableAttributesForType(Microsoft.CodeAnalysis.TypeInfo instantiatedType, ITypeSymbol convertedToTypeSymbol)
            {
                // This handles the case where there is an WinRT array possibly being assigned
                // to an object type or a list. In this case, the IList interfaces of the array
                // type need to be put on the CCW.
                if (instantiatedType.Type is IArrayTypeSymbol arrayType)
                {
                    if (convertedToTypeSymbol is not IArrayTypeSymbol &&
                        // Make sure we aren't just assigning it to a value type such as ReadOnlySpan
                        !convertedToTypeSymbol.IsValueType)
                    {
                        if (visitedTypes.Contains(arrayType))
                        {
                            return;
                        }
                        visitedTypes.Add(arrayType);

                        var vtableAtribute = GetVtableAttributeToAdd(arrayType, isWinRTType, typeMapper, context.SemanticModel.Compilation, false);
                        if (vtableAtribute != default)
                        {
                            vtableAttributes.Add(vtableAtribute);
                        }

                        // Also add the enumerator type to the lookup table as the native caller can call it.
                        AddEnumeratorAdapterForType(arrayType.ElementType, typeMapper, context.SemanticModel.Compilation, isWinRTType, vtableAttributes);
                    }
                }
                else if (instantiatedType.Type is not null || instantiatedType.ConvertedType is not null)
                {
                    // Type might be null such as for lambdas, so check converted type in that case.
                    var instantiatedTypeSymbol = instantiatedType.Type ?? instantiatedType.ConvertedType;

                    if (visitedTypes.Contains(instantiatedTypeSymbol))
                    {
                        return;
                    }
                    visitedTypes.Add(instantiatedTypeSymbol);

                    // This handles the case where a generic delegate is passed to a parameter
                    // statically declared as an object and thereby we won't be able to detect
                    // its actual type and handle it at compile time within the generated projection.
                    // When it is not declared as an object parameter but rather the generic delegate
                    // type itself, the generated marshaler code in the function makes sure the vtable
                    // information is available.
                    if (instantiatedTypeSymbol.TypeKind == TypeKind.Delegate &&
                        instantiatedTypeSymbol.MetadataName.Contains("`") &&
                        isWinRTType(instantiatedTypeSymbol, typeMapper) &&
                        convertedToTypeSymbol.SpecialType == SpecialType.System_Object)
                    {
                        var argumentClassNamedTypeSymbol = instantiatedTypeSymbol as INamedTypeSymbol;
                        var vtableAtribute = GetVtableAttributeToAdd(instantiatedTypeSymbol, isWinRTType, typeMapper, context.SemanticModel.Compilation, false);
                        if (vtableAtribute != default)
                        {
                            vtableAttributes.Add(vtableAtribute);
                        }
                    }

                    // This handles the case where the source generator wasn't able to run
                    // and put the WinRTExposedType attribute on the class. This can be in the
                    // scenario where the caller defined their own generic class and
                    // pass it as a parameter.  With generic classes, the interface itself
                    // might be generic too and due to that we handle it here.
                    // This also handles the case where the type being passed is from a different
                    // library which happened to not run the AOT optimizer.  So as a best effort,
                    // we handle it here.
                    if (instantiatedTypeSymbol.TypeKind == TypeKind.Class)
                    {
                        bool addClassOnLookupTable = false;
                        if (instantiatedTypeSymbol.MetadataName.Contains("`"))
                        {
                            addClassOnLookupTable =
                                !GeneratorHelper.HasWinRTExposedTypeAttribute(instantiatedTypeSymbol) &&
                                // If the type is defined in the same assembly as what the source generator is running on,
                                // we let the WinRTExposedType attribute generator handle it. The only scenario the generator
                                // doesn't handle which we handle here is if it is a generic type implementing generic WinRT interfaces.
                                (!SymbolEqualityComparer.Default.Equals(instantiatedTypeSymbol.ContainingAssembly, context.SemanticModel.Compilation.Assembly) || 
                                  GeneratorHelper.HasNonInstantiatedWinRTGeneric(instantiatedTypeSymbol.OriginalDefinition, typeMapper)) &&
                                // Make sure the type we are passing is being boxed or cast to another interface.
                                !SymbolEqualityComparer.Default.Equals(instantiatedTypeSymbol, convertedToTypeSymbol);
                        }
                        else if (!isWinRTType(instantiatedTypeSymbol, typeMapper))
                        {
                            addClassOnLookupTable =
                                !GeneratorHelper.HasWinRTExposedTypeAttribute(instantiatedTypeSymbol) &&
                                // If the type is defined in the same assembly as what the source generator is running on,
                                // we let the WinRTExposedType attribute generator handle it.
                                !SymbolEqualityComparer.Default.Equals(instantiatedTypeSymbol.ContainingAssembly, context.SemanticModel.Compilation.Assembly) &&
                                // Make sure the type we are passing is being boxed or cast to another interface.
                                !SymbolEqualityComparer.Default.Equals(instantiatedTypeSymbol, convertedToTypeSymbol);
                        }

                        if (addClassOnLookupTable)
                        {
                            var vtableAtribute = GetVtableAttributeToAdd(instantiatedTypeSymbol, isWinRTType, typeMapper, context.SemanticModel.Compilation, false);
                            if (vtableAtribute != default)
                            {
                                vtableAttributes.Add(vtableAtribute);
                            }

                            AddVtableAdapterTypeForKnownInterface(instantiatedTypeSymbol, context.SemanticModel.Compilation, isWinRTType, typeMapper, vtableAttributes);
                        }
                    }
                }
            }
        }

        private static EquatableArray<VtableAttribute> GetVtableAttributesToAddOnLookupTable(
            GeneratorAttributeSyntaxContext context,
            TypeMapper typeMapper,
            bool isCsWinRTComponent)
        {
            var isWinRTType = !isCsWinRTComponent ? GeneratorHelper.IsWinRTType : GeneratorHelper.IsWinRTTypeWithPotentialAuthoringComponentTypesFunc(context.SemanticModel.Compilation);
            HashSet<VtableAttribute> vtableAttributes = new();

            foreach (var attributeData in context.Attributes)
            {
                if (attributeData.ConstructorArguments is [{ Kind: TypedConstantKind.Type, Value : ITypeSymbol vtableType }])
                {
                    if (vtableType is IArrayTypeSymbol arrayType)
                    {
                        var vtableAtribute = GetVtableAttributeToAdd(arrayType, isWinRTType, typeMapper, context.SemanticModel.Compilation, false);
                        if (vtableAtribute != default)
                        {
                            vtableAttributes.Add(vtableAtribute);
                        }

                        // Also add the enumerator type to the lookup table as the native caller can call it.
                        AddEnumeratorAdapterForType(arrayType.ElementType, typeMapper, context.SemanticModel.Compilation, isWinRTType, vtableAttributes);
                    }
                    else
                    {
                        var vtableAtribute = GetVtableAttributeToAdd(vtableType, isWinRTType, typeMapper, context.SemanticModel.Compilation, false);
                        if (vtableAtribute != default)
                        {
                            vtableAttributes.Add(vtableAtribute);
                        }

                        AddVtableAdapterTypeForKnownInterface(vtableType, context.SemanticModel.Compilation, isWinRTType, typeMapper, vtableAttributes);
                    }
                }
            }

            return vtableAttributes.ToImmutableArray();
        }

        // Any of the IEnumerable interfaces on the vtable can be used to get the enumerator.  Given IEnumerable is
        // a covariant interface, it means that we can end up getting an instance of the enumerable adapter for any one
        // of those covariant interfaces and thereby need vtable lookup entries for all of them.
        private static void AddEnumeratorAdapterForType(ITypeSymbol type, TypeMapper mapper, Compilation compilation, Func<ISymbol, TypeMapper, bool> isWinRTType, HashSet<VtableAttribute> vtableAttributes)
        {
            var enumerableType = compilation.GetTypeByMetadataName("System.Collections.Generic.IEnumerable`1");
            if (enumerableType != null)
            {
                var constructedEnumerableType = enumerableType.Construct(type);
                if (TryGetCompatibleWindowsRuntimeTypesForVariantType(constructedEnumerableType, mapper, null, isWinRTType, out var compatibleIfaces))
                {
                    foreach (var compatibleIface in compatibleIfaces)
                    {
                        if (compatibleIface.MetadataName == "IEnumerable`1" &&
                            !GeneratorHelper.IsInternalInterfaceFromReferences(compatibleIface, compilation.Assembly))
                        {
                            var enumeratorAdapterType = compilation.GetTypeByMetadataName("ABI.System.Collections.Generic.ToAbiEnumeratorAdapter`1");
                            if (enumeratorAdapterType != null)
                            {
                                var constructedEnumeratorAdapterType = enumeratorAdapterType.Construct(compatibleIface.TypeArguments[0]);
                                var vtableAttribute = GetVtableAttributeToAdd(constructedEnumeratorAdapterType, isWinRTType, mapper, compilation, false);
                                if (vtableAttribute != default)
                                {
                                    vtableAttributes.Add(vtableAttribute);
                                }
                            }
                        }
                    }
                }
            }
        }

        internal static void AddVtableAdapterTypeForKnownInterface(ITypeSymbol classType, Compilation compilation, Func<ISymbol, TypeMapper, bool> isWinRTType, TypeMapper mapper, HashSet<VtableAttribute> vtableAttributes)
        {
            foreach (var iface in classType.AllInterfaces)
            {
                if (iface.MetadataName == "IEnumerable`1")
                {
                    AddEnumeratorAdapterForType(iface.TypeArguments[0], mapper, compilation, isWinRTType, vtableAttributes);
                }
                else if (iface.MetadataName == "IDictionary`2")
                {
                    LookupAndAddVtableAttributeForGenericType("System.Collections.ObjectModel.ReadOnlyDictionary`2", iface.TypeArguments);
                    LookupAndAddVtableAttributeForGenericType("System.Collections.Generic.KeyValuePair`2", iface.TypeArguments);
                    LookupAndAddVtableAttributeForGenericType("ABI.System.Collections.Generic.ConstantSplittableMap`2", iface.TypeArguments);
                }
                else if (iface.MetadataName == "IList`1")
                {
                    LookupAndAddVtableAttributeForGenericType("System.Collections.ObjectModel.ReadOnlyCollection`1", iface.TypeArguments);
                }
            }

            if (classType is INamedTypeSymbol namedType && IsDerivedFromOrIsObservableCollection(namedType))
            {
                // ObservableCollection make use of two internal built-in types as part of its
                // implementation for INotifyPropertyChanged.  Handling those manually here.
                var genericInterfaces = new List<string>() { "System.Collections.IList", "System.Collections.IEnumerable" };
                var mapping = mapper.GetMappedType("System.Collections.IList").GetMapping();
                var runtimeClassName = mapping.Item1 + "." + mapping.Item2;

                // System.Collections.Specialized.ReadOnlyList
                vtableAttributes.Add(
                    new VtableAttribute(
                        "System.Collections.Specialized",
                        false,
                        "ReadOnlyList",
                        ImmutableArray<TypeInfo>.Empty,
                        "System.Collections.Specialized.ReadOnlyList",
                        genericInterfaces.ToImmutableArray(),
                        ImmutableArray<GenericInterface>.Empty,
                        false,
                        false,
                        false,
                        runtimeClassName));

                // System.Collections.Specialized.SingleItemReadOnlyList
                vtableAttributes.Add(
                    new VtableAttribute(
                        "System.Collections.Specialized",
                        false,
                        "SingleItemReadOnlyList",
                        ImmutableArray<TypeInfo>.Empty,
                        "System.Collections.Specialized.SingleItemReadOnlyList",
                        genericInterfaces.ToImmutableArray(),
                        ImmutableArray<GenericInterface>.Empty,
                        false,
                        false,
                        false,
                        runtimeClassName));
            }

            void LookupAndAddVtableAttributeForGenericType(string type, ImmutableArray<ITypeSymbol> genericArgs)
            {
                var genericType = compilation.GetTypeByMetadataName(type);
                if (genericType != default)
                {
                    var constructedGenericType = genericType.Construct([.. genericArgs]);
                    var vtableAttribute = GetVtableAttributeToAdd(constructedGenericType, isWinRTType, mapper, compilation, false);
                    if (vtableAttribute != default)
                    {
                        vtableAttributes.Add(vtableAttribute);
                    }
                }
            }

            bool IsDerivedFromOrIsObservableCollection(INamedTypeSymbol namedType)
            {
                return namedType.MetadataName == "ObservableCollection`1" || 
                    (namedType.BaseType is not null && IsDerivedFromOrIsObservableCollection(namedType.BaseType));
            }
        }

        private static void GenerateVtableLookupTable(
            SourceProductionContext sourceProductionContext,
            (ImmutableArray<VtableAttribute> vtableAttributes, (CsWinRTAotOptimizerProperties properties, string)) value)
        {
            GenerateVtableLookupTable(sourceProductionContext.AddSource, value);
        }

        internal static void GenerateVtableLookupTable(
            Action<string, string> addSource, 
            (ImmutableArray<VtableAttribute> vtableAttributes, (CsWinRTAotOptimizerProperties properties, string escapedAssemblyName) context) value,
            bool isComponentGenerator = false)
        {
            if (!value.context.properties.IsCsWinRTAotOptimizerEnabled || !value.context.properties.IsCsWinRTCcwLookupTableGeneratorEnabled)
            {
                return;
            }

            StringBuilder source = new();
            string classPrefix = isComponentGenerator ? "Authoring" : "";

            // The generated lookup table is based on lookup by string rather than type to avoid 2 different issues:
            //
            //     1) We can run into nested private types in generics which we can't reference from here but still need to be able to create the vtable for.
            //     2) While looking for a type in the lookup table, you can trigger module initializers for other modules
            //        referenced and that can run into issues because they can have their own lookup tables that
            //        get registered in their module initializer, but will fail to due to the reader writer lock we have around it
            //        (i.e. we are traversing the lookup tables here while one is being registered).
            //
            // Note: just like with the authoring metadata function, we don't use a method group expression but rather construct a 'Func<Type, string>' ourselves.
            // This is done to opt-out of the implicit caching that Roslyn does. We don't need that extra code and overhead, as this is only done once.
            var hasRuntimeClasNameEntries = value.vtableAttributes.Any(static v => !string.IsNullOrEmpty(v.RuntimeClassName));
            if (value.vtableAttributes.Any())
            {
                source.AppendLine($$"""
                                    using System; 
                                    using System.Runtime.InteropServices;
                                    using System.Runtime.CompilerServices;

                                    namespace WinRT.{{value.context.escapedAssemblyName}}GenericHelpers
                                    {

                                        internal static class {{classPrefix}}GlobalVtableLookup
                                        {

                                            [System.Runtime.CompilerServices.ModuleInitializer]
                                            internal static void InitializeGlobalVtableLookup()
                                            {
                                                ComWrappersSupport.RegisterTypeComInterfaceEntriesLookup(new Func<Type, ComWrappers.ComInterfaceEntry[]>(LookupVtableEntries));
                                                {{(hasRuntimeClasNameEntries ? "ComWrappersSupport.RegisterTypeRuntimeClassNameLookup(new Func<Type, string>(LookupRuntimeClassName));" : "")}}
                                            }

                                            private static ComWrappers.ComInterfaceEntry[] LookupVtableEntries(Type type)
                                            {
                                                string typeName = type.ToString();
                                    """);
            }

            // We gather all the class names that have the same vtable and generate it
            // as part of one if to reduce generated code.
            var vtableEntryToClassNameList = new Dictionary<VtableEntry, List<string>>();
            foreach (var vtableAttribute in value.vtableAttributes.ToImmutableHashSet())
            {
                VtableEntry entry = new(vtableAttribute.Interfaces, vtableAttribute.GenericInterfaces, vtableAttribute.IsDelegate);
                if (!vtableEntryToClassNameList.TryGetValue(entry, out var classNameList))
                {
                    classNameList = new List<string>();
                    vtableEntryToClassNameList.Add(entry, classNameList);
                }
                classNameList.Add(vtableAttribute.VtableLookupClassName);
            }

            foreach (var vtableEntry in vtableEntryToClassNameList)
            {
                source.AppendLine($$"""
                                if (typeName == "{{vtableEntry.Value[0]}}"
                    """);

                for (var i = 1; i < vtableEntry.Value.Count; i++)
                {
                    source.AppendLine($$"""
                                    || typeName == "{{vtableEntry.Value[i]}}"
                        """);
                }

                source.AppendLine($$"""
                                )
                                {
                                    {{GenerateVtableEntry(vtableEntry.Key, value.context.escapedAssemblyName)}}
                                }
                    """);
            }

            if (value.vtableAttributes.Any())
            {
                source.AppendLine($$"""
                                                return default;
                                            }
                                    """);

                if (hasRuntimeClasNameEntries)
                {
                    source.AppendLine($$"""
                                private static string LookupRuntimeClassName(Type type)
                                {
                                    string typeName = type.ToString();
                                """);

                    var runtimeClassNameToClassNameList = new Dictionary<string, List<string>>();
                    foreach (var vtableAttribute in value.vtableAttributes.ToImmutableHashSet().Where(static v => !string.IsNullOrEmpty(v.RuntimeClassName)))
                    {
                        if (!runtimeClassNameToClassNameList.TryGetValue(vtableAttribute.RuntimeClassName, out var classNameList))
                        {
                            classNameList = new List<string>();
                            runtimeClassNameToClassNameList.Add(vtableAttribute.RuntimeClassName, classNameList);
                        }
                        classNameList.Add(vtableAttribute.VtableLookupClassName);
                    }

                    foreach (var entry in runtimeClassNameToClassNameList)
                    {
                        source.AppendLine($$"""
                                if (typeName == "{{entry.Value[0]}}"
                                """);

                        for (var i = 1; i < entry.Value.Count; i++)
                        {
                            source.AppendLine($$"""
                                    || typeName == "{{entry.Value[i]}}"
                                    """);
                        }

                        source.AppendLine($$"""
                                )
                                {
                                    return "{{entry.Key}}";
                                }
                                """);
                    }

                    source.AppendLine($$"""
                                                return default;
                                            }
                                    """);
                }

                source.AppendLine($$"""
                                        }
                                    }
                                    """);
                addSource($"WinRT{classPrefix}GlobalVtableLookup.g.cs", source.ToString());
            }
        }

        private static void GenerateBindableCustomProperties(
            SourceProductionContext sourceProductionContext,
            (ImmutableArray<BindableCustomProperties> bindableCustomProperties, CsWinRTAotOptimizerProperties properties) value)
        {
            if (!value.properties.IsCsWinRTAotOptimizerEnabled || value.bindableCustomProperties.Length == 0)
            {
                return;
            }

            StringBuilder source = new();

            foreach (var bindableCustomProperties in value.bindableCustomProperties)
            {
                if (!bindableCustomProperties.IsGlobalNamespace)
                {
                    source.AppendLine($$"""
                        namespace {{bindableCustomProperties.Namespace}}
                        {
                        """);
                }

                var escapedClassName = GeneratorHelper.EscapeTypeNameForIdentifier(bindableCustomProperties.TypeName);

                ReadOnlySpan<TypeInfo> classHierarchy = bindableCustomProperties.ClassHierarchy.AsSpan();
                // If the type is nested, correctly nest the type definition
                for (int i = classHierarchy.Length - 1; i > 0; i--)
                {
                    source.AppendLine($$"""
                                partial {{classHierarchy[i].GetTypeKeyword()}} {{classHierarchy[i].QualifiedName}}
                                {
                                """);
                }

                string typeKeyword = TypeInfo.GetTypeKeyword(bindableCustomProperties.TypeKind, bindableCustomProperties.IsRecord);

                source.AppendLine($$"""
                            partial {{typeKeyword}} {{(classHierarchy.IsEmpty ? bindableCustomProperties.TypeName : classHierarchy[0].QualifiedName)}} : global::Microsoft.UI.Xaml.Data.IBindableCustomPropertyImplementation
                            {
                                global::Microsoft.UI.Xaml.Data.BindableCustomProperty global::Microsoft.UI.Xaml.Data.IBindableCustomPropertyImplementation.GetProperty(string name)
                                {
                            """);

                foreach (var property in bindableCustomProperties.Properties.Where(static p => !p.IsIndexer))
                {
                    var instanceAccessor = property.IsStatic ? bindableCustomProperties.QualifiedClassName : $$"""(({{bindableCustomProperties.QualifiedClassName}})instance)""";

                    source.AppendLine($$"""
                                if (name == "{{property.Name}}")
                                {
                                    return new global::Microsoft.UI.Xaml.Data.BindableCustomProperty(
                                        {{GetBoolAsString(property.CanRead)}},
                                        {{GetBoolAsString(property.CanWrite)}},
                                        "{{property.Name}}",
                                        typeof({{property.Type}}),
                                        {{ (property.CanRead ? $$"""static (instance) => {{instanceAccessor}}.{{property.Name}}""" : "null") }},
                                        {{ (property.CanWrite ? $$"""static (instance, value) => {{instanceAccessor}}.{{property.Name}} = ({{property.Type}})value""" : "null") }},
                                        null,
                                        null);
                                }
                        """);
                }

                source.AppendLine($$"""
                        return default;
                    }

                    global::Microsoft.UI.Xaml.Data.BindableCustomProperty global::Microsoft.UI.Xaml.Data.IBindableCustomPropertyImplementation.GetProperty(global::System.Type indexParameterType)
                    {
                """);

                foreach (var property in bindableCustomProperties.Properties.Where(static p => p.IsIndexer))
                {
                    var instanceAccessor = property.IsStatic ? bindableCustomProperties.QualifiedClassName : $$"""(({{bindableCustomProperties.QualifiedClassName}})instance)""";

                    source.AppendLine($$"""
                                if (indexParameterType == typeof({{property.IndexerType}}))
                                {
                                    return new global::Microsoft.UI.Xaml.Data.BindableCustomProperty(
                                        {{GetBoolAsString(property.CanRead)}},
                                        {{GetBoolAsString(property.CanWrite)}},
                                        "{{property.Name}}",
                                        typeof({{property.Type}}),
                                        null,
                                        null,
                                        {{ (property.CanRead ? $$"""static (instance, index) => {{instanceAccessor}}[({{property.IndexerType}})index]""" : "null") }},
                                        {{ (property.CanWrite ? $$"""static (instance, value, index) => {{instanceAccessor}}[({{property.IndexerType}})index] = ({{property.Type}})value""" : "null") }});
                                }
                        """);
                }

                source.AppendLine($$"""
                        return default;
                    }
                }
                """);

                // Close all brackets
                for (int i = classHierarchy.Length - 1; i > 0; i--)
                {
                    source.AppendLine("}");
                }

                if (!bindableCustomProperties.IsGlobalNamespace)
                {
                    source.AppendLine($@"}}");
                }

                source.AppendLine();
            }

            sourceProductionContext.AddSource("WinRTCustomBindableProperties.g.cs", source.ToString());

            static string GetBoolAsString(bool value) => value ? "true" : "false";
        }
    }

    internal readonly record struct GenericParameter(
        string ProjectedType,
        string AbiType,
        TypeKind TypeKind);

    internal readonly record struct GenericInterface(
        string Interface,
        string GenericDefinition,
        EquatableArray<GenericParameter> GenericParameters);

    internal sealed record VtableAttribute(
        string Namespace,
        bool IsGlobalNamespace,
        string ClassName,
        EquatableArray<TypeInfo> ClassHierarchy,
        string VtableLookupClassName,
        EquatableArray<string> Interfaces,
        EquatableArray<GenericInterface> GenericInterfaces,
        bool IsArray,
        bool IsDelegate,
        bool IsPublic,
        string RuntimeClassName = default);

    sealed record VtableEntry(
        EquatableArray<string> Interfaces,
        EquatableArray<GenericInterface> GenericInterfaces,
        bool IsDelegate);

    internal readonly record struct BindableCustomProperty(
        string Name,
        string Type,
        bool CanRead,
        bool CanWrite,
        bool IsIndexer,
        string IndexerType,
        bool IsStatic);

    internal readonly record struct BindableCustomProperties(
        string Namespace,
        bool IsGlobalNamespace,
        string TypeName,
        TypeKind TypeKind,
        bool IsRecord,
        EquatableArray<TypeInfo> ClassHierarchy,
        string QualifiedClassName,
        EquatableArray<BindableCustomProperty> Properties);

    internal readonly record struct CsWinRTAotOptimizerProperties(
        bool IsCsWinRTAotOptimizerEnabled,
        bool IsCsWinRTComponent,
        bool IsCsWinRTCcwLookupTableGeneratorEnabled,
        bool IsCsWinRTAotOptimizerInAutoMode);

    /// <summary>
    /// A model describing a type info in a type hierarchy.
    /// </summary>
    /// <param name="QualifiedName">The qualified name for the type.</param>
    /// <param name="Kind">The kind of the type in the hierarchy.</param>
    /// <param name="IsRecord">Whether the type is a record type.</param>
    // Ported from https://github.com/Sergio0694/ComputeSharp
    internal sealed record TypeInfo(string QualifiedName, TypeKind Kind, bool IsRecord)
    {
        /// <summary>
        /// Gets the keyword for the current type kind.
        /// </summary>
        /// <returns>The keyword for the current type kind.</returns>
        public string GetTypeKeyword()
        {
            return GetTypeKeyword(Kind, IsRecord);
        }

        /// <summary>
        /// Gets the keyword for a given kind and record option.
        /// </summary>
        /// <param name="kind">The type kind.</param>
        /// <param name="isRecord">Whether the type is a record.</param>
        /// <returns>The keyword for a given kind and record option.</returns>
        public static string GetTypeKeyword(TypeKind kind, bool isRecord)
        {
            return kind switch
            {
                TypeKind.Struct when isRecord => "record struct",
                TypeKind.Struct => "struct",
                TypeKind.Interface => "interface",
                TypeKind.Class when isRecord => "record",
                _ => "class"
            };
        }
    }
}
