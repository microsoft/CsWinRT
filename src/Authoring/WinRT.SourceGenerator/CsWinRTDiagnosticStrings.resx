<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArrayMarkedInOrOut_Brief" xml:space="preserve">
    <value>Array parameter marked InAttribute or OutAttribute</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text1" xml:space="preserve">
    <value>Method '{0}' has parameter '{1}' which is an array, and which has either a System.Runtime.InteropServices.InAttribute or a System.Runtime.InteropServices.OutAttribute.</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text2" xml:space="preserve">
    <value>In the Windows Runtime, array parameters must have either ReadOnlyArray or WriteOnlyArray.</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text3" xml:space="preserve">
    <value>Please remove these attributes or replace them with the appropriate Windows Runtime attribute if necessary.</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Brief" xml:space="preserve">
    <value>Array parameter marked `out` and ReadOnlyArray</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Text1" xml:space="preserve">
    <value>Method '{0}' has an output parameter '{1}' which is an array, but which has ReadOnlyArray attribute.</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Text2" xml:space="preserve">
    <value>In the Windows Runtime, the contents of output arrays are writable. Please remove the attribute from '{1}'.</value>
  </data>
  <data name="ArrayParamMarkedBoth_Brief" xml:space="preserve">
    <value>Array paramter marked both ReadOnlyArray and WriteOnlyArray</value>
  </data>
  <data name="ArrayParamMarkedBoth_Text1" xml:space="preserve">
    <value>Method '{0}' has parameter '{1}' which is an array, and which has both ReadOnlyArray and WriteOnlyArray.</value>
  </data>
  <data name="ArrayParamMarkedBoth_Text2" xml:space="preserve">
    <value>In the Windows Runtime, the contents array parameters must be either readable or writable, please remove one of the attributes from '{1}'.</value>
  </data>
  <data name="ArrayParamNotMarked_Brief" xml:space="preserve">
    <value>Array parameter not marked ReadOnlyArray or WriteOnlyArray way</value>
  </data>
  <data name="ArrayParamNotMarked_Text1" xml:space="preserve">
    <value>Method '{0}' has parameter '{1}' which is an array.</value>
  </data>
  <data name="ArrayParamNotMarked_Text2" xml:space="preserve">
    <value>In the Windows Runtime, the contents of array parameters must be either readable or writable; please apply either ReadOnlyArray or WriteOnlyArray to '{1}'.</value>
  </data>
  <data name="ClassConstructorRule_Brief" xml:space="preserve">
    <value>Class Constructor Rule</value>
  </data>
  <data name="ClassConstructorRule_Text" xml:space="preserve">
    <value>Classes cannot have multiple constructors of the same arity in the Windows Runtime, class {0} has multiple {1}-arity constructors</value>
  </data>
  <data name="ClassImplementsOldProjection_Brief" xml:space="preserve">
    <value>Class not trimming / AOT compatible</value>
  </data>
  <data name="ClassImplementsOldProjection_Text" xml:space="preserve">
    <value>Class '{0}' implements WinRT interface(s) {1} generated using an older version of CsWinRT.  Update to a projection generated using CsWinRT 2.1.0 or later for trimming and AOT compatibility.</value>
  </data>
  <data name="ClassOldProjectionMultipleInstances_Text" xml:space="preserve">
    <value>Class '{0}' was generated using an older version of CsWinRT and due to the type being defined in multiple DLLs, CsWinRT can not generate compat code to make it trimming safe.  Update to a projection generated using CsWinRT 2.1.0 or later for trimming and AOT compatibility.</value>
  </data>
  <data name="ClassNotMarkedPartial_Brief" xml:space="preserve">
    <value>Class is not marked partial</value>
  </data>
  <data name="ClassNotMarkedPartial_Text" xml:space="preserve">
    <value>Class '{0}' implements WinRT interfaces but it or a parent type isn't marked partial.  Type and any parent types should be marked partial for trimming and AOT compatibility if passed across the WinRT ABI.</value>
  </data>
  <data name="BindableCustomPropertyClassNotMarkedPartial_Text" xml:space="preserve">
    <value>Class '{0}' has attribute GeneratedBindableCustomProperty but it or a parent type isn't marked partial.  Type and any parent types should be marked partial to allow source generation for trimming and AOT compatibility.</value>
  </data>
  <data name="DisjointNamespaceRule_Brief" xml:space="preserve">
    <value>Namespace is disjoint from main (winmd) namespace</value>
  </data>
  <data name="DisjointNamespaceRule_Text1" xml:space="preserve">
    <value>A public type has a namespace ('{1}') that shares no common prefix with other namespaces ('{0}').</value>
    <comment>{1} and {0} will be some user-defined keyword</comment>
  </data>
  <data name="DisjointNamespaceRule_Text2" xml:space="preserve">
    <value>All types within a Windows Metadata file must exist in a sub namespace of the namespace that is implied by the file name.</value>
    <comment>"sub namespace" means a namespace defined within another namespace</comment>
  </data>
  <data name="EnableUnsafe_Brief" xml:space="preserve">
    <value>Project does not enable unsafe blocks</value>
  </data>
  <data name="EnableUnsafe_Text" xml:space="preserve">
    <value>Type '{0}' implements generic WinRT interfaces which requires generated code using unsafe for trimming and AOT compatibility if passed across the WinRT ABI. Project needs to be updated with '&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;'.</value>
  </data>
  <data name="GenericTypeRule_Brief" xml:space="preserve">
    <value>Class (or interface) is generic</value>
  </data>
  <data name="GenericTypeRule_Text" xml:space="preserve">
    <value>Type {0} is generic, Windows Runtime types cannot be generic</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="JaggedArrayRule_Brief" xml:space="preserve">
    <value>Array signature found with jagged array, which is not a valid WinRT type</value>
  </data>
  <data name="JaggedArrayRule_Text" xml:space="preserve">
    <value>Method {0} has a nested array of type {1} in its signature; arrays in Windows Runtime method signature cannot be nested</value>
  </data>
  <data name="MultiDimensionalArrayRule_Brief" xml:space="preserve">
    <value>Array signature found with multi-dimensional array, which is not a valid Windows Runtime type</value>
  </data>
  <data name="MultiDimensionalArrayRule_Text" xml:space="preserve">
    <value>Method '{0}' has a multi-dimensional array of type '{1}' in its signature; arrays in Windows Runtime method signatures must be one dimensional</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Brief" xml:space="preserve">
    <value>Only one overload should be designated default</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Text1" xml:space="preserve">
    <value>In class {2}: Multiple {0}-parameter overloads of '{1}' are decorated with Windows.Foundation.Metadata.DefaultOverloadAttribute.</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Text2" xml:space="preserve">
    <value>The attribute may only be applied to one overload of the method.</value>
  </data>
  <data name="NamespacesDifferByCase_Brief" xml:space="preserve">
    <value>Namespace names cannot differ only by case</value>
  </data>
  <data name="NamespacesDifferByCase_Text" xml:space="preserve">
    <value>Multiple namespaces found with the name '{0}'; namespace names cannot differ only by case in the Windows Runtime</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="NeedDefaultOverloadAttribute_Brief" xml:space="preserve">
    <value>Multiple overloads seen without DefaultOverload attribute</value>
  </data>
  <data name="NeedDefaultOverloadAttribute_Text" xml:space="preserve">
    <value>In class {2}: The {0}-parameter overloads of {1} must have exactly one method specified as the default overload by decorating it with Windows.Foundation.Metadata.DefaultOverloadAttribute</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Brief" xml:space="preserve">
    <value>Parameter (not array type) marked InAttribute or OutAttribute</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Text1" xml:space="preserve">
    <value>Method '{0}' has parameter '{1}' with a System.Runtime.InteropServices.InAttribute or System.Runtime.InteropServices.OutAttribute.Windows Runtime does not support marking parameters with System.Runtime.InteropServices.InAttribute or System.Runtime.InteropServices.OutAttribute.</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Text2" xml:space="preserve">
    <value>Please consider removing System.Runtime.InteropServices.InAttribute and replace System.Runtime.InteropServices.OutAttribute with 'out' modifier instead.</value>
  </data>
  <data name="NonArrayMarked_Brief" xml:space="preserve">
    <value>Non-array parameter marked with ReadOnlyArray or WriteOnlyArray</value>
  </data>
  <data name="NonArrayMarked_Text1" xml:space="preserve">
    <value>Method '{0}' has parameter '{1}' which is not an array, and which has either a ReadOnlyArray attribute or a WriteOnlyArray attribute.</value>
  </data>
  <data name="NonArrayMarked_Text2" xml:space="preserve">
    <value>Windows Runtime does not support marking non-array parameters with ReadOnlyArray or WriteOnlyArray.</value>
  </data>
  <data name="NonWinRTInterface_Brief" xml:space="preserve">
    <value>Invalid Interface Inherited</value>
  </data>
  <data name="NonWinRTInterface_Text" xml:space="preserve">
    <value>Windows Runtime component type {0} cannot implement interface {1}, as the interface is not a valid Windows Runtime interface</value>
  </data>
  <data name="NoPublicTypesRule_Brief" xml:space="preserve">
    <value>No public types defined</value>
  </data>
  <data name="NoPublicTypesRule_Text" xml:space="preserve">
    <value>Windows Runtime components must have at least one public type</value>
  </data>
  <data name="OperatorOverloadedRule_Brief" xml:space="preserve">
    <value>Operator overload exposed</value>
  </data>
  <data name="OperatorOverloadedRule_Text" xml:space="preserve">
    <value>{0} is an operator overload, managed types cannot expose operator overloads in the Windows Runtime</value>
  </data>
  <data name="ParameterNamedValueRule_Brief" xml:space="preserve">
    <value>Parameter Named Value Rule</value>
  </data>
  <data name="ParameterNamedValueRule_Text" xml:space="preserve">
    <value>The parameter name {1} in method {0} is the same as the return value parameter name used in the generated C#/WinRT interop; use a different parameter name</value>
  </data>
  <data name="PrivateGetterRule_Brief" xml:space="preserve">
    <value>Property must have public getter</value>
  </data>
  <data name="PrivateGetterRule_Text" xml:space="preserve">
    <value>Property '{0}' does not have a public getter method. Windows Runtime does not support setter-only properties.</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="RefParameterFound_Brief" xml:space="preserve">
    <value>Parameter passed by reference</value>
  </data>
  <data name="StructHasConstFieldRule_Brief" xml:space="preserve">
    <value>Const field in struct</value>
  </data>
  <data name="StructHasConstFieldRule_Text" xml:space="preserve">
    <value>Structure {0} has const field - constants can only appear on Windows Runtime enumerations.</value>
  </data>
  <data name="StructHasInvalidFieldRule_Brief" xml:space="preserve">
    <value>Invalid field in struct</value>
  </data>
  <data name="StructHasInvalidFieldRule_Text1" xml:space="preserve">
    <value>Structure {0} has field of type {1}; {1} is not a valid Windows Runtime field type.</value>
  </data>
  <data name="StructHasInvalidFieldRule_Text2" xml:space="preserve">
    <value>Each field in a Windows Runtime structure can only be UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Boolean, String, Enum, or itself a structure.</value>
  </data>
  <data name="StructHasPrivateFieldRule_Brief" xml:space="preserve">
    <value>Private field in struct</value>
  </data>
  <data name="StructHasPrivateFieldRule_Text" xml:space="preserve">
    <value>Structure {0} has non-public field. All fields must be public for Windows Runtime structures.</value>
  </data>
  <data name="StructWithNoFieldsRule_Brief" xml:space="preserve">
    <value>Empty struct rule</value>
  </data>
  <data name="StructWithNoFieldsRule_Text" xml:space="preserve">
    <value>Structure {0} contains no public fields. Windows Runtime structures must contain at least one public field.</value>
  </data>
  <data name="UnimplementedInterface_Brief" xml:space="preserve">
    <value>Class incorrectly implements an interface</value>
  </data>
  <data name="UnimplementedInterface_Text" xml:space="preserve">
    <value>Class '{0}' does not correctly implement interface '{1}' because member '{2}' is missing or non-public</value>
  </data>
  <data name="UnsealedClassRule_Brief" xml:space="preserve">
    <value>Class is unsealed</value>
  </data>
  <data name="UnsealedClassRule_Text" xml:space="preserve">
    <value>Exporting unsealed types is not supported in CsWinRT, please mark type {0} as sealed</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="UnsupportedTypeRule_Brief" xml:space="preserve">
    <value>Exposing unsupported type</value>
  </data>
  <data name="UnsupportedTypeRule_Text1" xml:space="preserve">
    <value>The member '{0}' has the type '{1}' in its signature.</value>
    <comment>{0} and {1} will be user-defined keywords</comment>
  </data>
  <data name="UnsupportedTypeRule_Text2" xml:space="preserve">
    <value>The type '{1}' is not a valid Windows Runtime type.</value>
    <comment>{1} will be some user-defined keyword</comment>
  </data>
  <data name="UnsupportedTypeRule_Text3" xml:space="preserve">
    <value>Yet, the type (or its generic parameters) implement interfaces that are valid Windows Runtime types.</value>
  </data>
  <data name="UnsupportedTypeRule_Text4" xml:space="preserve">
    <value>Consider changing the type '{1} in the member signature to one of the following types from System.Collections.Generic: {2}.</value>
    <comment>{1} and {2} will be keywords (types) from DotNet</comment>
  </data>
  <data name="RefParameterFound_Text" xml:space="preserve">
    <value>Method '{0}' has parameter '{1}' marked `ref`; reference parameters are not allowed in Windows Runtime</value>
  </data>
  <data name="SourceGeneratorFailed_Brief" xml:space="preserve">
    <value>Source generator failed</value>
  </data>
  <data name="SourceGeneratorFailed_Text" xml:space="preserve">
    <value>Source generator failed to create WinMD because of '{0}'</value>
  </data>
</root>