<?xml version="1.0" encoding="utf-8"?>
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArrayMarkedInOrOut_Brief" xml:space="preserve">
    <value>标记为 InAttribute 或 OutAttribute 的数组参数</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text1" xml:space="preserve">
    <value>方法'{0}'具有作为数组的参数 '{1}'，该参数具有 System.Runtime.InteropServices.InAttribute 或 System.Runtime.InteropServices.OutAttribute。</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text2" xml:space="preserve">
    <value>在 Windows 运行时中，数组参数必须具有 ReadOnlyArray 或 WriteOnlyArray。</value>
  </data>
  <data name="ArrayMarkedInOrOut_Text3" xml:space="preserve">
    <value>如有必要，请删除这些属性或将其替换为适当的Windows 运行时属性。</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Brief" xml:space="preserve">
    <value>标记为‘out’和 ReadOnlyArray 的数组参数</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Text1" xml:space="preserve">
    <value>方法‘{0}’为具有输出参数‘{1}’的数组，但具有 ReadOnlyArray 属性。</value>
  </data>
  <data name="ArrayOutputParamMarkedRead_Text2" xml:space="preserve">
    <value>在 Windows 运行时中，输出数组的内容是可写入的。请从‘{1}’中删除属性。</value>
  </data>
  <data name="ArrayParamMarkedBoth_Brief" xml:space="preserve">
    <value>数组参数标记为 ReadOnlyArray 和 WriteOnlyArray</value>
  </data>
  <data name="ArrayParamMarkedBoth_Text1" xml:space="preserve">
    <value>方法‘{0}’为具有参数‘{1}’的数组，同时具有 ReadOnlyArray 和 WriteOnlyArray。</value>
  </data>
  <data name="ArrayParamMarkedBoth_Text2" xml:space="preserve">
    <value>在 Windows 运行时中，内容数组参数必须可读或可写，请从‘{1}’中删除其中一个属性。</value>
  </data>
  <data name="ArrayParamNotMarked_Brief" xml:space="preserve">
    <value>数组参数未标记为 ReadOnlyArray 或 WriteOnlyArray 方式</value>
  </data>
  <data name="ArrayParamNotMarked_Text1" xml:space="preserve">
    <value>方法‘{0}’为具有参数‘{1}’的数组。</value>
  </data>
  <data name="ArrayParamNotMarked_Text2" xml:space="preserve">
    <value>在 Windows 运行时中，数组参数的内容必须可读或可写; 请将 ReadOnlyArray 或 WriteOnlyArray 应用于‘{1}’。</value>
  </data>
  <data name="ClassConstructorRule_Brief" xml:space="preserve">
    <value>类构造函数规则</value>
  </data>
  <data name="ClassConstructorRule_Text" xml:space="preserve">
    <value>类不能在 Windows 运行时中具有多个同一性的构造函数，类 {0} 具有多个 {1}-性构造函数</value>
  </data>
  <data name="DisjointNamespaceRule_Brief" xml:space="preserve">
    <value>命名空间与主 (winmd) 命名空间不相互连接</value>
  </data>
  <data name="DisjointNamespaceRule_Text1" xml:space="preserve">
    <value>公共类型具有一个命名空间 (‘{1}’)，该命名空间与其他命名空间 (‘{0}’) 不共享公共前缀。</value>
    <comment>{1} and {0} will be some user-defined keyword</comment>
  </data>
  <data name="DisjointNamespaceRule_Text2" xml:space="preserve">
    <value>Windows 元数据文件中的所有类型都必须存在于该文件名隐含的命名空间的子命名空间中。</value>
    <comment>"sub namespace" means a namespace defined within another namespace</comment>
  </data>
  <data name="GenericTypeRule_Brief" xml:space="preserve">
    <value>类 (或接口) 为泛型</value>
  </data>
  <data name="GenericTypeRule_Text" xml:space="preserve">
    <value>类型 {0} 为泛型，Windows 运行时类型不能为泛型</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="JaggedArrayRule_Brief" xml:space="preserve">
    <value>发现数组签名有锯齿状阵列，这不是有效的WinRT类型</value>
  </data>
  <data name="JaggedArrayRule_Text" xml:space="preserve">
    <value>方法 {0} 的签名中具有 {1} 类型的嵌套数组; 无法嵌套 Windows 运行时方法签名中的数组</value>
  </data>
  <data name="MultiDimensionalArrayRule_Brief" xml:space="preserve">
    <value>使用多维数组找到数组签名，该数组不是有效的Windows 运行时类型</value>
  </data>
  <data name="MultiDimensionalArrayRule_Text" xml:space="preserve">
    <value>方法‘{0}’的签名中具有类型为‘{1}’的多维数组; Windows 运行时方法签名中的数组必须是一维的</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Brief" xml:space="preserve">
    <value>默认情况下只应指定一个重载</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Text1" xml:space="preserve">
    <value>在类 {2} 中;‘{1}’的多个 {0}-参数重载使用 Windows.Foundation.Metadata.DefaultOverloadAttribute 进行修饰。</value>
  </data>
  <data name="MultipleDefaultOverloadAttribute_Text2" xml:space="preserve">
    <value>该属性只能应用于方法的一个重载。</value>
  </data>
  <data name="NamespacesDifferByCase_Brief" xml:space="preserve">
    <value>命名空间名称不能仅因大小写而异</value>
  </data>
  <data name="NamespacesDifferByCase_Text" xml:space="preserve">
    <value>找到名称为‘{0}’的多个名称空间; 在Windows 运行时中，名称空间的名称不能只因大小写而不同</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="NeedDefaultOverloadAttribute_Brief" xml:space="preserve">
    <value>在没有 DefaultOverload 属性的情况下看到多个重载</value>
  </data>
  <data name="NeedDefaultOverloadAttribute_Text" xml:space="preserve">
    <value>在类 {2}: {1} 的 {0}-参数重载必须通过使用 Windows.Foundation.Metadata.DefaultOverloadAttribute 对其进行修饰，将其指定为默认重载</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Brief" xml:space="preserve">
    <value>标记为 InAttribute 或 OutAttribute 的参数 (非数组类型)</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Text1" xml:space="preserve">
    <value>方法‘{0}’具有带 System.Runtime.InteropServices.InAttribute 或 System.Runtime.InteropServices.OutAttribute 的参数‘{1}’。Windows 运行时不支持使用 System.Runtime.InteropServices.InAttribute 或 System.Runtime.InteropServices.OutAttribute 标记参数。</value>
  </data>
  <data name="NonArrayMarkedInOrOut_Text2" xml:space="preserve">
    <value>请考虑删除 System.Runtime.InteropServices.InAttribute，并将 System.Runtime.InteropServices.OutAttribute 替换为‘out’修饰符。</value>
  </data>
  <data name="NonArrayMarked_Brief" xml:space="preserve">
    <value>标有 ReadOnlyArray 或 WriteOnlyArray 的非数组参数</value>
  </data>
  <data name="NonArrayMarked_Text1" xml:space="preserve">
    <value>方法‘{0}’具有不为数组的参数‘{1}，并且其具有 ReadOnlyArray 特性或 WriteOnlyArray 特性。</value>
  </data>
  <data name="NonArrayMarked_Text2" xml:space="preserve">
    <value>Windows 运行时不支持使用 ReadOnlyArray 或 WriteOnlyArray 标记非数组参数。</value>
  </data>
  <data name="NonWinRTInterface_Brief" xml:space="preserve">
    <value>继承的接口无效</value>
  </data>
  <data name="NonWinRTInterface_Text" xml:space="preserve">
    <value>Windows 运行时组件类型{0}无法实现接口{1}，因为该接口不是有效的Windows 运行时接口</value>
  </data>
  <data name="NoPublicTypesRule_Brief" xml:space="preserve">
    <value>未定义公共类型</value>
  </data>
  <data name="NoPublicTypesRule_Text" xml:space="preserve">
    <value>Windows 运行时组件必须至少有一个公共类型</value>
  </data>
  <data name="OperatorOverloadedRule_Brief" xml:space="preserve">
    <value>运算符重载已公开</value>
  </data>
  <data name="OperatorOverloadedRule_Text" xml:space="preserve">
    <value>{0} 运算符重载，托管类型无法在 Windows 运行时中公开运算符重载</value>
  </data>
  <data name="ParameterNamedValueRule_Brief" xml:space="preserve">
    <value>参数命名值规则</value>
  </data>
  <data name="ParameterNamedValueRule_Text" xml:space="preserve">
    <value>方法{0}中{1}的参数名称与生成的 C#/WinRT 互操作中使用的返回值参数名称相同;使用其他参数名称</value>
  </data>
  <data name="PrivateGetterRule_Brief" xml:space="preserve">
    <value>属性必须具有公共 getter</value>
  </data>
  <data name="PrivateGetterRule_Text" xml:space="preserve">
    <value>属性'{0}'没有公共 getter 方法。Windows 运行时不支持仅 setter 属性。</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="RefParameterFound_Brief" xml:space="preserve">
    <value>通过引用传递的参数</value>
  </data>
  <data name="RefParameterFound_Text" xml:space="preserve">
    <value>方法‘{0}’具有标记为‘ref’的参数‘{1}’; Windows 运行时中不允许使用引用参数</value>
  </data>
  <data name="StructHasConstFieldRule_Brief" xml:space="preserve">
    <value>结构中的常量字段</value>
  </data>
  <data name="StructHasConstFieldRule_Text" xml:space="preserve">
    <value>结构{0}具有常量字段 - 常量只能出现在Windows 运行时枚举上。</value>
  </data>
  <data name="StructHasInvalidFieldRule_Brief" xml:space="preserve">
    <value>结构中的字段无效</value>
  </data>
  <data name="StructHasInvalidFieldRule_Text1" xml:space="preserve">
    <value>结构{0}具有{1}类型的字段;{1}不是有效的Windows 运行时字段类型。</value>
  </data>
  <data name="StructHasInvalidFieldRule_Text2" xml:space="preserve">
    <value>Windows 运行时结构中的每个字段只能是 UInt8、Int16、UInt16、Int32、UInt32、Int64、UInt64、Single、Double、Boolean、String、Enum 或其自身的结构。</value>
  </data>
  <data name="StructHasPrivateFieldRule_Brief" xml:space="preserve">
    <value>结构中的专用字段</value>
  </data>
  <data name="StructHasPrivateFieldRule_Text" xml:space="preserve">
    <value>结构 {0} 具有非公共字段。对于 Windows 运行时结构，所有字段都必须为公共字段。</value>
  </data>
  <data name="StructWithNoFieldsRule_Brief" xml:space="preserve">
    <value>空结构规则</value>
  </data>
  <data name="StructWithNoFieldsRule_Text" xml:space="preserve">
    <value>结构{0}不包含公共字段。Windows 运行时结构必须至少包含一个公共字段。</value>
  </data>
  <data name="UnimplementedInterface_Brief" xml:space="preserve">
    <value>类错误地实现接口</value>
  </data>
  <data name="UnimplementedInterface_Text" xml:space="preserve">
    <value>类‘{0}’未正确实现接口‘{1}’，因为缺少成员‘{2}’或非公开</value>
  </data>
  <data name="UnsealedClassRule_Brief" xml:space="preserve">
    <value>类以解封</value>
  </data>
  <data name="UnsealedClassRule_Text" xml:space="preserve">
    <value>CsWinRT 中不支持导出未密封的类型，请将类型{0}标记为密封</value>
    <comment>{0} will be some user-defined keyword</comment>
  </data>
  <data name="UnsupportedTypeRule_Brief" xml:space="preserve">
    <value>公开不受支持的类型</value>
  </data>
  <data name="UnsupportedTypeRule_Text1" xml:space="preserve">
    <value>成员‘{0}’在其签名中具有类型‘{1}’。</value>
    <comment>{0} and {1} will be user-defined keywords</comment>
  </data>
  <data name="UnsupportedTypeRule_Text2" xml:space="preserve">
    <value>类型'{1}'不是有效的Windows 运行时类型。</value>
    <comment>{1} will be some user-defined keyword</comment>
  </data>
  <data name="UnsupportedTypeRule_Text3" xml:space="preserve">
    <value>但是，类型 (或其泛型参数) 实现的接口是有效的 Windows 运行时类型。</value>
  </data>
  <data name="UnsupportedTypeRule_Text4" xml:space="preserve">
    <value>请考虑将成员签名中的类型‘{1} 更改为 System.Collections.Generic 中的以下类型之一: {2}。</value>
    <comment>{1} and {2} will be keywords (types) from DotNet</comment>
  </data>
</root>