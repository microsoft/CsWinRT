// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#if ROSLYN_4_12_0_OR_GREATER

using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Operations;
using WinRT.SourceGenerator;

#nullable enable

namespace Generator;

/// <summary>
/// A diagnostic analyzer to warn on potentially trim-unsafe casts to WinRT runtime classes.
/// </summary>
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public sealed class RuntimeClassCastAnalyzer : DiagnosticAnalyzer
{
    /// <inheritdoc/>
    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } = [WinRTRules.RuntimeClassCast, WinRTRules.IReferenceTypeCast];

    /// <inheritdoc/>
    public override void Initialize(AnalysisContext context)
    {
        // We're intentionally not analyzing generated code, as we don't want to generate warnings for XAML-generated code.
        // Casts in code-behind files are fine, for two main reasons:
        //   - Many code paths generated by the XAML compiler will use 'Cast<T>', which will root metadata
        //   - All those types used in casts will also have lots of static references, which further roots them enough. The main
        //     issue with casts is mostly just with types that just "pop in" from some external call, without any static references.
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        context.RegisterCompilationStartAction(static context =>
        {
            // Enable the analyzer when in the warning level is at least 3, as these warnings can be quite noisy
            if (GeneratorExecutionContextHelper.GetCsWinRTAotWarningLevel(context.Options.AnalyzerConfigOptionsProvider) < 3)
            {
                return;
            }

            // We should always have the '[WindowsRuntimeType]' attribute, and we need it to detect projected types
            if (context.Compilation.GetTypeByMetadataName("WinRT.WindowsRuntimeTypeAttribute") is not INamedTypeSymbol windowsRuntimeTypeAttribute)
            {
                return;
            }

            // Also try to get 'System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute' if present
            INamedTypeSymbol? dynamicDependencyAttribute = context.Compilation.GetTypeByMetadataName("System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute");

            // Helper to check a given method symbol
            bool IsDynamicDependencyPropertyForSymbol(ISymbol? symbol, INamedTypeSymbol classType)
            {
                if (symbol is null || dynamicDependencyAttribute is null)
                {
                    return false;
                }

                foreach (AttributeData attributeData in symbol.EnumerateAttributesWithType(dynamicDependencyAttribute))
                {
                    // We don't need to validate the other parameters. Using '[DynamicDependency]' is a very advanced scenario.
                    // As long as the type matches, we assume the developer knows what they're doing here, so we don't warn.
                    if (attributeData.ConstructorArguments is [_, { Kind: TypedConstantKind.Type, IsNull: false, Value: INamedTypeSymbol typeSymbol }] &&
                        SymbolEqualityComparer.Default.Equals(typeSymbol, classType))
                    {
                        return true;
                    }
                }

                return false;
            }

            // Helper to check if the containing method for a given operation has the right annotation already
            bool IsDynamicDependencyPresentForOperation(IOperation? operation, INamedTypeSymbol classType)
            {
                return operation switch
                {
                    IAnonymousFunctionOperation { Symbol: IMethodSymbol lambdaMethod } =>
                        IsDynamicDependencyPropertyForSymbol(lambdaMethod, classType) ||
                        IsDynamicDependencyPresentForOperation(operation.Parent, classType),
                    ILocalFunctionOperation { Symbol: IMethodSymbol localMethod } =>
                        IsDynamicDependencyPropertyForSymbol(localMethod, classType) ||
                        IsDynamicDependencyPresentForOperation(operation.Parent, classType),
                    IMethodBodyBaseOperation bodyOperation => IsDynamicDependencyPropertyForSymbol(operation.SemanticModel?.GetDeclaredSymbol(operation.Syntax) as IMethodSymbol, classType),
                    IFieldInitializerOperation fieldInitializer => IsDynamicDependencyPropertyForSymbol(fieldInitializer.InitializedFields.FirstOrDefault(), classType),
                    { } => IsDynamicDependencyPresentForOperation(operation.Parent, classType),
                    null => false
                };
            }

            // This handles the following cases:
            //
            // C c1 = (C)obj;        
            // C c2 = obj as C;
            context.RegisterOperationAction(context =>
            {
                if (context.Operation is not IConversionOperation { IsImplicit: false, Type: INamedTypeSymbol { IsStatic: false } outerTypeSymbol } conversion)
                {
                    return;
                }

                // Match class, enum types, and also nullable enum types (and unwrap them, if so)
                INamedTypeSymbol? innerTypeSymbol = outerTypeSymbol switch
                {
                    { TypeKind: TypeKind.Class or TypeKind.Enum } => outerTypeSymbol,
                    {
                        TypeKind: TypeKind.Struct,
                        IsGenericType: true,
                        IsUnboundGenericType: false,
                        ConstructedFrom.SpecialType: SpecialType.System_Nullable_T,
                        TypeArguments: [INamedTypeSymbol { TypeKind: TypeKind.Enum } underlyingType]
                    } => underlyingType,
                    _ => null
                };

                if (innerTypeSymbol is null)
                {
                    return;
                }

                if (innerTypeSymbol.HasAttributeWithType(windowsRuntimeTypeAttribute) &&
                    conversion.Operand is { Type.IsReferenceType: true } and not { ConstantValue: { HasValue: true, Value: null } } &&
                    !context.Compilation.HasImplicitConversion(conversion.Operand.Type, innerTypeSymbol) &&
                    !IsDynamicDependencyPresentForOperation(context.Operation, innerTypeSymbol))
                {
                    // We're intentionally passing 'outerTypeSymbol' as argument, so we show the original type name in the message
                    context.ReportDiagnostic(Diagnostic.Create(
                        innerTypeSymbol.TypeKind is TypeKind.Class ? WinRTRules.RuntimeClassCast : WinRTRules.IReferenceTypeCast,
                        context.Operation.Syntax.GetLocation(),
                        outerTypeSymbol));
                }
            }, OperationKind.Conversion);

            // This handles the following cases:
            //
            // if (obj is C)
            // {
            // }
            context.RegisterOperationAction(context =>
            {
                if (context.Operation is IIsTypeOperation { IsImplicit: false, TypeOperand: INamedTypeSymbol { TypeKind: TypeKind.Class or TypeKind.Enum, IsStatic: false } typeSymbol } typeOperation &&
                    typeSymbol.HasAttributeWithType(windowsRuntimeTypeAttribute) &&
                    typeOperation.ValueOperand.Type is { IsReferenceType: true } &&
                    !context.Compilation.HasImplicitConversion(typeOperation.ValueOperand.Type, typeSymbol) &&
                    !IsDynamicDependencyPresentForOperation(context.Operation, typeSymbol))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        typeSymbol.TypeKind is TypeKind.Class ? WinRTRules.RuntimeClassCast : WinRTRules.IReferenceTypeCast,
                        context.Operation.Syntax.GetLocation(),
                        typeSymbol));
                }
            }, OperationKind.IsType);

            // This handles the following cases:
            //
            // if (obj is C ic)
            // {
            // }
            //
            // List patterns are also handled:
            //
            // if (items is [C ic, ..])
            // {
            // }
            context.RegisterOperationAction(context =>
            {
                if (context.Operation is IDeclarationPatternOperation { IsImplicit: false, MatchedType: INamedTypeSymbol { TypeKind: TypeKind.Class or TypeKind.Enum, IsStatic: false } typeSymbol } patternOperation &&
                    typeSymbol.HasAttributeWithType(windowsRuntimeTypeAttribute) &&
                    patternOperation.InputType.IsReferenceType &&
                    !context.Compilation.HasImplicitConversion(patternOperation.InputType, typeSymbol) &&
                    !IsDynamicDependencyPresentForOperation(context.Operation, typeSymbol))
                {
                    // Adjust the location for 'obj is C ic' patterns, to include the 'is' expression as well
                    Location location = context.Operation.Parent is IIsPatternOperation isPatternOperation
                        ? isPatternOperation.Syntax.GetLocation()
                        : context.Operation.Syntax.GetLocation();

                    context.ReportDiagnostic(Diagnostic.Create(
                        typeSymbol.TypeKind is TypeKind.Class ? WinRTRules.RuntimeClassCast : WinRTRules.IReferenceTypeCast,
                        location,
                        typeSymbol));
                }
            }, OperationKind.DeclarationPattern);

            // This handles the following cases:
            //
            // if (items is [C, ..])
            // {
            // }
            context.RegisterOperationAction(context =>
            {
                if (context.Operation is ITypePatternOperation { IsImplicit: false, MatchedType: INamedTypeSymbol { TypeKind: TypeKind.Class or TypeKind.Enum, IsStatic: false } typeSymbol } patternOperation &&
                    typeSymbol.HasAttributeWithType(windowsRuntimeTypeAttribute) &&
                    patternOperation.InputType.IsReferenceType &&
                    !context.Compilation.HasImplicitConversion(patternOperation.InputType, typeSymbol) &&
                    !IsDynamicDependencyPresentForOperation(context.Operation, typeSymbol))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        typeSymbol.TypeKind is TypeKind.Class ? WinRTRules.RuntimeClassCast : WinRTRules.IReferenceTypeCast,
                        context.Operation.Syntax.GetLocation(),
                        typeSymbol));
                }
            }, OperationKind.TypePattern);
        });
    }
}

#endif
