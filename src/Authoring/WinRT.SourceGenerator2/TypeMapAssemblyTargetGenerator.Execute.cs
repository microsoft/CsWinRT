// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;

#pragma warning disable IDE0008

namespace WindowsRuntime.SourceGenerator;

/// <inheritdoc cref="TypeMapAssemblyTargetGenerator"/>
public partial class TypeMapAssemblyTargetGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Generation methods for <see cref="TypeMapAssemblyTargetGenerator"/>.
    /// </summary>
    private static class Execute
    {
        /// <summary>
        /// Gets all assembly names for all referenced Windows Runtime reference assemblies.
        /// </summary>
        /// <param name="data">The input data.</param>
        /// <param name="token">The cancellation token for the operation.</param>
        /// <returns>The assembly names for all referenced Windows Runtime reference assemblies..</returns>
        public static ImmutableArray<string> GetAllWindowsRuntimeReferenceAssemblyNames((Compilation Compilation, bool IsEnabled) data, CancellationToken token)
        {
            // Bypass the entire operation if the generator is disabled
            if (!data.IsEnabled)
            {
                return [];
            }

            ITypeSymbol attributeSymbol = data.Compilation.GetTypeByMetadataName("WindowsRuntime.InteropServices.WindowsRuntimeReferenceAssemblyAttribute")!;

            // Try to get a good initial capacity (if we fail, just use '0', since private projections are not common)
            if (!Enumerable.TryGetNonEnumeratedCount(data.Compilation.References, out int initialCapacity))
            {
                initialCapacity = 0;
            }

            var assemblyNames = ImmutableArray.CreateBuilder<string>(initialCapacity);

            foreach (MetadataReference metadataReference in data.Compilation.References)
            {
                token.ThrowIfCancellationRequested();

                // We are only interested in PE references (not project references)
                if (metadataReference is not PortableExecutableReference)
                {
                    continue;
                }

                // Make sure we can resolve the symbol for the assembly from the reference
                if (data.Compilation.GetAssemblyOrModuleSymbol(metadataReference) is not IAssemblySymbol assemblySymbol)
                {
                    continue;
                }

                // If the assembly has '[WindowsRuntimeReferenceAssembly]', track its name
                if (assemblySymbol.HasAttributeWithType(attributeSymbol))
                {
                    assemblyNames.Add(assemblySymbol.Identity.Name);
                }
            }

            token.ThrowIfCancellationRequested();

            // Also sort the assembly names (both for better incrementality and to make the output more readable)
            assemblyNames.Sort(StringComparer.OrdinalIgnoreCase);

            return assemblyNames.DrainToImmutable();
        }

        /// <summary>
        /// Emits the <see cref="System.Runtime.InteropServices.TypeMapAssemblyTargetAttribute{TTypeMapGroup}"/> items for all private projections.
        /// </summary>
        /// <param name="context">The <see cref="SourceProductionContext"/> instance to use.</param>
        /// <param name="assemblyNames">The input assembly names.</param>
        public static void EmitPrivateProjectionsTypeMapAssemblyTargetAttributes(SourceProductionContext context, ImmutableArray<string> assemblyNames)
        {
            if (assemblyNames.IsEmpty)
            {
                return;
            }

            StringBuilder builder = new();

            _ = builder.AppendLine($"""
                // <auto-generated/>
                #pragma warning disable

                """);

            // Add a '[TypeMapAssemblyTarget]' entry for each assembly
            foreach (string assemblyName in assemblyNames)
            {
                _ = builder.AppendLine($"""
                    [assembly: global::System.Runtime.InteropServices.TypeMapAssemblyTarget<global::WindowsRuntime.InteropServices.WindowsRuntimeComWrappersTypeMapGroup>("{assemblyName}")]
                    """);
            }

            context.AddSource("TypeMapAssemblyTarget.PrivateProjections.g.cs", builder.ToString());
        }

        /// <summary>
        /// Emits the <see cref="System.Runtime.InteropServices.TypeMapAssemblyTargetAttribute{TTypeMapGroup}"/> items for the default assemblies.
        /// </summary>
        /// <param name="context">The <see cref="SourceProductionContext"/> instance to use.</param>
        /// <param name="isEnabled">Whether the generator is enabled.</param>
        public static void EmitDefaultTypeMapAssemblyTargetAttributes(SourceProductionContext context, bool isEnabled)
        {
            if (!isEnabled)
            {
                return;
            }

            const string source = """
                // <auto-generated/>
                #pragma warning disable

                [assembly: global::System.Runtime.InteropServices.TypeMapAssemblyTarget<global::WindowsRuntime.InteropServices.WindowsRuntimeComWrappersTypeMapGroup>("WinRT.Interop")]
                //[assembly: global::System.Runtime.InteropServices.TypeMapAssemblyTarget<global::WindowsRuntime.InteropServices.WindowsRuntimeComWrappersTypeMapGroup>("WinRT.Projection")]
                [assembly: global::System.Runtime.InteropServices.TypeMapAssemblyTarget<global::WindowsRuntime.InteropServices.WindowsRuntimeComWrappersTypeMapGroup>("WinRT.Runtime2")]
                """;

            context.AddSource("TypeMapAssemblyTarget.g.cs", source);
        }
    }
}
