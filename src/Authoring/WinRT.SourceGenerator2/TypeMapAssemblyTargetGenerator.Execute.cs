// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System.Collections.Immutable;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;

#pragma warning disable IDE0008

namespace WindowsRuntime.SourceGenerator;

/// <inheritdoc cref="TypeMapAssemblyTargetGenerator"/>
public partial class TypeMapAssemblyTargetGenerator : IIncrementalGenerator
{
    /// <summary>
    /// Generation methods for <see cref="TypeMapAssemblyTargetGenerator"/>.
    /// </summary>
    private static class Execute
    {
        /// <summary>
        /// Gets all portable executable references from a compilation.
        /// </summary>
        /// <param name="data">The input data.</param>
        /// <param name="token">The cancellation token for the operation.</param>
        /// <returns>All portable executable references for the input compilation.</returns>
        public static ImmutableArray<EquatablePortableExecutableReference> GetAllPortableExecutableReferences((Compilation Compilation, bool IsEnabled) data, CancellationToken token)
        {
            // Bypass the entire operation if the generator is disabled
            if (!data.IsEnabled)
            {
                return [];
            }

            var executableReferences = ImmutableArray.CreateBuilder<EquatablePortableExecutableReference>();

            foreach (MetadataReference metadataReference in data.Compilation.References)
            {
                token.ThrowIfCancellationRequested();

                // We are only interested in PE references (not project references)
                if (metadataReference is not PortableExecutableReference executableReference)
                {
                    continue;
                }

                executableReferences.Add(new EquatablePortableExecutableReference(executableReference, data.Compilation));
            }

            token.ThrowIfCancellationRequested();

            return executableReferences.ToImmutable();
        }

        /// <summary>
        /// Gets the assembly name for the input assembly, if it is a Windows Runtime reference assembly.
        /// </summary>
        /// <param name="executableReference">The input <see cref="EquatablePortableExecutableReference"/> instance.</param>
        /// <param name="token">The cancellation token for the operation.</param>
        /// <returns>The assembly name for <paramref name="executableReference"/>, if it is a Windows Runtime reference assembly.</returns>
        public static string? GetAssemblyNameIfWindowsRuntimeReferenceAssembly(EquatablePortableExecutableReference executableReference, CancellationToken token)
        {
            Compilation compilation = executableReference.GetCompilationUnsafe();

            token.ThrowIfCancellationRequested();

            // We only care about resolved assembly symbols (this should always be the case anyway)
            if (compilation.GetAssemblyOrModuleSymbol(executableReference.Reference) is not IAssemblySymbol assemblySymbol)
            {
                return null;
            }

            token.ThrowIfCancellationRequested();

            ITypeSymbol attributeSymbol = compilation.GetTypeByMetadataName("WindowsRuntime.InteropServices.WindowsRuntimeReferenceAssemblyAttribute")!;

            token.ThrowIfCancellationRequested();

            return assemblySymbol.HasAttributeWithType(attributeSymbol) ? assemblySymbol.Identity.Name : null;
        }

        /// <summary>
        /// Emits the <see cref="System.Runtime.InteropServices.TypeMapAssemblyTargetAttribute{TTypeMapGroup}"/> items for all private projections.
        /// </summary>
        /// <param name="context">The <see cref="SourceProductionContext"/> instance to use.</param>
        /// <param name="assemblyNames">The input assembly names.</param>
        public static void EmitPrivateProjectionsTypeMapAssemblyTargetAttributes(SourceProductionContext context, EquatableArray<string> assemblyNames)
        {
            if (assemblyNames.IsEmpty)
            {
                return;
            }

            StringBuilder builder = new();

            _ = builder.AppendLine($"""
                // <auto-generated/>
                #pragma warning disable

                """);

            // Add a '[TypeMapAssemblyTarget]' entry for each assembly
            foreach (string assemblyName in assemblyNames)
            {
                _ = builder.AppendLine($"""
                    [assembly: global::System.Runtime.InteropServices.TypeMapAssemblyTarget<global::WindowsRuntime.InteropServices.WindowsRuntimeComWrappersTypeMapGroup>("{assemblyName}")]
                    """);
            }

            context.AddSource("TypeMapAssemblyTarget.PrivateProjections.g.cs", builder.ToString());
        }

        /// <summary>
        /// Emits the <see cref="System.Runtime.InteropServices.TypeMapAssemblyTargetAttribute{TTypeMapGroup}"/> items for the default assemblies.
        /// </summary>
        /// <param name="context">The <see cref="SourceProductionContext"/> instance to use.</param>
        /// <param name="isEnabled">Whether the generator is enabled.</param>
        public static void EmitDefaultTypeMapAssemblyTargetAttributes(SourceProductionContext context, bool isEnabled)
        {
            if (!isEnabled)
            {
                return;
            }

            const string source = """
                // <auto-generated/>
                #pragma warning disable

                [assembly: global::System.Runtime.InteropServices.TypeMapAssemblyTarget<global::WindowsRuntime.InteropServices.WindowsRuntimeComWrappersTypeMapGroup>("WinRT.Interop")]
                //[assembly: global::System.Runtime.InteropServices.TypeMapAssemblyTarget<global::WindowsRuntime.InteropServices.WindowsRuntimeComWrappersTypeMapGroup>("WinRT.Projection")]
                [assembly: global::System.Runtime.InteropServices.TypeMapAssemblyTarget<global::WindowsRuntime.InteropServices.WindowsRuntimeComWrappersTypeMapGroup>("WinRT.Runtime2")]
                """;

            context.AddSource("TypeMapAssemblyTarget.g.cs", source);
        }
    }
}
