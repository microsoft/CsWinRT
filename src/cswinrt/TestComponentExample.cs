//------------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by cswinrt.exe version 0.0.0-private.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace TestComponent
{
    [global::WinRT.WindowsRuntimeType("TestComponent", "struct(TestComponent.Blittable;u1;u2;u4;u8;i2;i4;i8;f4;f8;g16)")][global::WinRT.WindowsRuntimeHelperType][global::WinRT.WinRTExposedType(typeof(global::WinRT.StructTypeDetails<Blittable, Blittable>))]public struct Blittable: IEquatable<Blittable>
    {
        public byte A;
        public ushort B;
        public uint C;
        public ulong D;
        public short E;
        public int F;
        public long G;
        public float H;
        public double I;
        public Guid J;

        public Blittable(byte _A, ushort _B, uint _C, ulong _D, short _E, int _F, long _G, float _H, double _I, Guid _J)
        {
            A = _A; B = _B; C = _C; D = _D; E = _E; F = _F; G = _G; H = _H; I = _I; J = _J; 
        }

        public static bool operator ==(Blittable x, Blittable y) => x.A == y.A && x.B == y.B && x.C == y.C && x.D == y.D && x.E == y.E && x.F == y.F && x.G == y.G && x.H == y.H && x.I == y.I && x.J == y.J;
        public static bool operator !=(Blittable x, Blittable y) => !(x == y);
        public bool Equals(Blittable other) => this == other;
        public override bool Equals(object obj) => obj is Blittable that && this == that;
        public override int GetHashCode() => A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode() ^ E.GetHashCode() ^ F.GetHashCode() ^ G.GetHashCode() ^ H.GetHashCode() ^ I.GetHashCode() ^ J.GetHashCode();
    }
    [global::WinRT.WindowsRuntimeType("TestComponent", "struct(TestComponent.NonBlittable;b1;c2;string;pinterface({61c17706-2d65-11e0-9ae8-d48564015472};i8))")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.TestComponent.NonBlittable))][global::WinRT.WinRTExposedType(typeof(global::WinRT.StructTypeDetails<NonBlittable, global::ABI.TestComponent.NonBlittable>))]public struct NonBlittable: IEquatable<NonBlittable>
    {
        public bool A;
        public char B;
        public string C;
        public global::System.Nullable<long> D;

        public NonBlittable(bool _A, char _B, string _C, global::System.Nullable<long> _D)
        {
            A = _A; B = _B; C = _C; D = _D; 
        }

        public static bool operator ==(NonBlittable x, NonBlittable y) => x.A == y.A && x.B == y.B && x.C == y.C && x.D == y.D;
        public static bool operator !=(NonBlittable x, NonBlittable y) => !(x == y);
        public bool Equals(NonBlittable other) => this == other;
        public override bool Equals(object obj) => obj is NonBlittable that && this == that;
        public override int GetHashCode() => A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();
    }
}

#pragma warning disable CA1416
namespace ABI.TestComponent
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct NonBlittable
    {
        public byte A;
        public ushort B;
        public IntPtr C;
        public IntPtr D;

        public struct Marshaler
        {
            public MarshalString _C;
            public ObjectReferenceValue _D;
            public NonBlittable __abi;
            public void Dispose()
            {
                MarshalString.DisposeMarshaler(_C);
                MarshalInspectable<object>.DisposeMarshaler(_D);
            }
        }

        public static Marshaler CreateMarshaler(global::TestComponent.NonBlittable arg)
        {
            var m = new Marshaler();
            bool success = false;
            try
            {
                m._C = MarshalString.CreateMarshaler(arg.C);
                m._D = MarshalInterface<global::System.Nullable<long>>.CreateMarshaler2(arg.D);
                m.__abi = new NonBlittable()
                {
                    A = (byte)(arg.A ? 1 : 0)
                    , B = (ushort)arg.B
                    , C = MarshalString.GetAbi(m._C)
                    , D = MarshalInspectable<object>.GetAbi(m._D)
                };
                success = true;
                return m;
            }
            finally
            {
                if (!success)
                {
                    m.Dispose();
                }
            }
        }

        public static NonBlittable GetAbi(Marshaler m) => m.__abi;

        public static global::TestComponent.NonBlittable FromAbi(NonBlittable arg)
        {
            return new global::TestComponent.NonBlittable()
            {
                A = arg.A != 0
                , B = (char)arg.B
                , C = MarshalString.FromAbi(arg.C)
                , D = MarshalInterface<global::System.Nullable<long>>.FromAbi(arg.D)
            };
        }

        public static NonBlittable FromManaged(global::TestComponent.NonBlittable arg)
        {
            return new NonBlittable()
            {
                A = (byte)(arg.A ? 1 : 0)
                , B = (ushort)arg.B
                , C = MarshalString.FromManaged(arg.C)
                , D = MarshalInterface<global::System.Nullable<long>>.FromManaged(arg.D)
            };
        }

        public static unsafe void CopyAbi(Marshaler arg, IntPtr dest) => 
            *(NonBlittable*)dest.ToPointer() = GetAbi(arg);

        public static unsafe void CopyManaged(global::TestComponent.NonBlittable arg, IntPtr dest) =>
            *(NonBlittable*)dest.ToPointer() = FromManaged(arg);

        public static void DisposeMarshaler(Marshaler m) => m.Dispose();

        public static void DisposeAbi(NonBlittable abi)
        {
            MarshalString.DisposeAbi(abi.C);
            MarshalInterface<global::System.Nullable<long>>.DisposeAbi(abi.D);
        }
    }
}
#pragma warning restore CA1416
