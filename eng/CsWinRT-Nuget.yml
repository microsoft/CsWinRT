# 'Allow scripts to access the OAuth token' was selected in pipeline.  Add the following YAML to any steps requiring access:
#       env:
#           MY_ACCESS_TOKEN: $(System.AccessToken)
# Cron Schedules have been converted using UTC Time Zone and may need to be updated for your location
# Multi-job configuration must be converted to matrix strategy: https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=azure-devops&tabs=yaml#multi-job-configuration
trigger:
  branches:
    include:
    - master
  batch: True
schedules:
- cron: 0 1 * * *
  branches:
    include:
    - master
name: $(MajorVersion).$(MinorVersion).$(PatchVersion)$(PrereleaseVersion).$(date:yyMMdd)$(rev:.r)
resources:
  repositories:
  - repository: self
    type: git
    ref: master
jobs:
- job: Job_2
  displayName: Build and Test
  timeoutInMinutes: 90
  pool:
    vmImage: windows-2019
  steps:
  - checkout: self
    clean: true
    persistCredentials: True
  - task: CmdLine@2
    displayName: Clone TestWinRT
    enabled: False
    inputs:
      script: get_testwinrt.cmd
      workingDirectory: $(Build.SourcesDirectory)
  - task: PowerShell@2
    displayName: Download procdump
    enabled: False
    inputs:
      targetType: inline
      script: >
        mkdir $env:Agent_TempDirectory\procdump

        Invoke-WebRequest -Uri https://download.sysinternals.com/files/Procdump.zip -OutFile $env:Agent_TempDirectory\procdump\Procdump.zip

        Expand-Archive -Path $env:Agent_TempDirectory\procdump\Procdump.zip $env:Agent_TempDirectory\procdump\

        set PROCDUMP_PATH=$env:Agent_TempDirectory\procdump\

        Write-Host "##vso[task.setvariable variable=PATH;]${env:Agent_TempDirectory}\procdump;${env:PATH}";
  - task: UseDotNet@2
    displayName: Use .NET Core SDK 2.1
    inputs:
      version: 2.1.x
      installationPath: C:\Users\VssAdministrator\AppData\Local\Microsoft\dotnet\
      performMultiLevelLookup: true
  - task: PowerShell@2
    displayName: Install .NET 5 SDK
    inputs:
      targetType: inline
      script: "Write-Host \"##vso[task.setvariable variable=PATH;]${env:LocalAppData}\\Microsoft\\dotnet;${env:PATH}\";\n\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; \n\n&([scriptblock]::Create((Invoke-WebRequest -UseBasicParsing 'https://dot.net/v1/dotnet-install.ps1'))) -Version \"$($env:NET5_SDK_VERSION)\" -Architecture \"x64\" -AzureFeed \"$($env:NET5_SDK_FEED)\"\n"
      failOnStderr: true
  - task: PowerShell@2
    displayName: Install .NET 6 SDK
    inputs:
      targetType: inline
      script: "Write-Host \"##vso[task.setvariable variable=PATH;]${env:LocalAppData}\\Microsoft\\dotnet;${env:PATH}\";\n\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; \n\ndotnet new globaljson --sdk-version \"$($env:NET6_SDK_VERSION)\" \n\n&([scriptblock]::Create((Invoke-WebRequest -UseBasicParsing 'https://dot.net/v1/dotnet-install.ps1'))) -Version \"$($env:NET6_SDK_VERSION)\" -Architecture \"x64\" -AzureFeed \"$($env:NET5_SDK_FEED)\"\n"
      failOnStderr: true
  - task: CmdLine@2
    displayName: Verify .NET SDK
    inputs:
      script: >-
        where dotnet

        dotnet --info
      workingDirectory: $(Build.SourcesDirectory)
  - task: CmdLine@2
    displayName: Parse Versions
    inputs:
      script: "rem Parse the build-generated Build.BuildNumber into components that \nrem can be recombined for version resources, nuget packages, etc.\n\n@echo off\n\nrem Encode the build date/rev into a 16 bit value for resource versions\nif \"$(PrereleaseVersion)\"==\"\" (\nset RevisionBase=30000\n) else (\nset RevisionBase=0\n)\nfor /f \"tokens=4,5 delims=.\" %%i in (\"$(Build.BuildNumber)\") do set BuildMetadata=%%i.%%j & set /a BuildRevision=%RevisionBase%+(((%%i/10000)-20)*366+((%%i)%%10000)/100*31+((%%i)%%100))*10+%%j\n\nset VersionNumber=$(MajorVersion).$(MinorVersion).$(PatchVersion).%BuildRevision%\n\nif \"$(PrereleaseVersion)\"==\"\" (\nset NugetVersion=$(MajorVersion).$(MinorVersion).$(PatchVersion)\n) else (\nset NugetVersion=$(Build.BuildNumber)\n)\n\nrem Export generated version numbers back for subsequent tasks\necho ##vso[task.setvariable variable=BuildMetadata;]%BuildMetadata%\necho ##vso[task.setvariable variable=BuildRevision;]%BuildRevision%\necho ##vso[task.setvariable variable=VersionNumber;]%VersionNumber%\necho ##vso[task.setvariable variable=NugetVersion;]%NugetVersion%\n"
      workingDirectory: $(Build.SourcesDirectory)
  - task: CmdLine@2
    displayName: Build Prerelease Targets
    inputs:
      script: >
        if "$(PrereleaseVersion)"=="" goto :eof


        set prerelease_targets=nuget\Microsoft.Windows.CsWinRT.Prerelease.targets

        echo ^<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="CsWinRTVerifyPrerelease"^> > %prerelease_targets%

        echo   ^<Target Name="CsWinRTVerifyPrerelease" >> %prerelease_targets%

        echo     Condition=" '$(NetCoreSdkVersion)' ^!= '$($env:NET5_SDK_VERSION)' and '$(Net5SdkVersion)' ^!= '$($env:NET5_SDK_VERSION)' "^> >> %prerelease_targets%

        echo     ^<Warning Text="This C#/WinRT prerelease is designed for .Net SDK $($env:NET5_SDK_VERSION). Other versions may be incompatible due to breaking changes." /^> >> %prerelease_targets%

        echo   ^</Target^> >> %prerelease_targets%

        echo ^</Project^> >> %prerelease_targets%
      workingDirectory: $(Build.SourcesDirectory)
  - task: CmdLine@2
    displayName: Build Tool
    inputs:
      script: "if \"%VSCMD_VER%\"==\"\" (\n    pushd c:\n    call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\Common7\\Tools\\VsDevCmd.bat\" >nul 2>&1\n    popd\n)\n\nset cswinrt_echo=on\nset cswinrt_build_only=true\nset cswinrt_build_params=/bl:$(Build.SourcesDirectory)\\cswinrt.binlog /p:CleanIntermediateDirs=true\nbuild.cmd $(BuildPlatform) $(BuildConfiguration) $(VersionNumber) $(Build.BuildNumber) $(WinRT.Runtime.AssemblyVersion) \n"
      workingDirectory: $(Build.SourcesDirectory)\src
  - task: CmdLine@2
    displayName: Mask BuildConfiguration
    enabled: False
    inputs:
      script: >-
        @echo off


        rem Although BuildConfiguration is PipelineRelease or PipelineDebug, the build outputs still go to Release or Debug

        rem change BuildConfiguration variable so staging succeeds

        rem the alternative would be to add configuration property for Pipeline* to every project in cswinrt.sln


        if "$(BuildConfiguration)"=="PipelineRelease" (

        set NewBuildConfiguration=Release

        ) else if "$(BuildConfiguration)"=="PipelineDebug" (

        set NewBuildConfiguration=Debug

        )


        if "%NewBuildConfiguration%"!="" (

        echo ##vso[task.setvariable variable=BuildConfiguration;]%NewBuildConfiguration%

        )
  - task: ComponentGovernanceComponentDetection@0
    displayName: Component Detection
  - task: CopyFiles@2
    displayName: Stage BinLog
    condition: always()
    inputs:
      SourceFolder: $(Build.SourcesDirectory)
      Contents: cswinrt.binlog
      TargetFolder: $(Build.ArtifactStagingDirectory)\binlog
  - task: PublishBuildArtifacts@1
    displayName: Publish BinLog
    condition: always()
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)\binlog
      ArtifactName: $(BuildConfiguration)_$(BuildPlatform)_binlog
  - task: ArchiveFiles@2
    displayName: Stage Windows projection
    enabled: False
    inputs:
      rootFolderOrFile: $(Build.SourcesDirectory)\Projections\Windows\Generated Files
      includeRootFolder: false
      sevenZipCompression: 5
      archiveFile: $(Build.ArtifactStagingDirectory)\Windows\sources.zip
  - task: PublishBuildArtifacts@1
    displayName: Publish Windows projection
    enabled: False
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)\Windows
      ArtifactName: $(BuildConfiguration)_$(BuildPlatform)_Windows
  - task: CopyFiles@2
    displayName: Stage CsWinRT
    condition: and(succeeded(), or(eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildPlatform'], 'x64')))
    inputs:
      SourceFolder: $(Build.SourcesDirectory)\src\_build\$(BuildPlatform)\$(BuildConfiguration)\cswinrt\bin
      Contents: >-
        cswinrt.exe

        cswinrt.pdb
      TargetFolder: $(Build.ArtifactStagingDirectory)\native
  - task: CopyFiles@2
    displayName: Stage WinRT.Interop.winmd
    condition: and(succeeded(), or(eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildPlatform'], 'x64')))
    continueOnError: True
    inputs:
      SourceFolder: $(Build.SourcesDirectory)\src\_build\$(BuildPlatform)\$(BuildConfiguration)\cswinrt\bin
      Contents: WinRT.Interop.winmd
      TargetFolder: $(Build.ArtifactStagingDirectory)\native
  - task: CopyFiles@2
    displayName: Stage WinRT.Host
    continueOnError: True
    inputs:
      SourceFolder: $(Build.SourcesDirectory)\src\_build\$(BuildPlatform)\$(BuildConfiguration)\WinRT.Host\bin
      Contents: >-
        WinRT.Host.dll

        WinRT.Host.pdb
      TargetFolder: $(Build.ArtifactStagingDirectory)\native
  - task: CopyFiles@2
    displayName: Stage Unit Test
    condition: and(succeeded(), or(eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildPlatform'], 'x64')))
    inputs:
      SourceFolder: $(Build.SourcesDirectory)\src\Tests\UnitTest\bin\$(BuildPlatform)\$(BuildConfiguration)\net5.0
      Contents: >-
        unittest.dll

        unittest.pdb
      TargetFolder: $(Build.ArtifactStagingDirectory)\native
  - task: PublishBuildArtifacts@1
    displayName: Publish Native
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)\native
      ArtifactName: $(BuildConfiguration)_$(BuildPlatform)
  - task: CopyFiles@2
    displayName: Stage NetStandard 2.0
    condition: and(succeeded(), eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildConfiguration'], 'release'))
    inputs:
      SourceFolder: $(Build.SourcesDirectory)\src\WinRT.Runtime\bin\$(BuildConfiguration)\netstandard2.0
      Contents: >-
        WinRT.Runtime.dll

        WinRT.Runtime.pdb
      TargetFolder: $(Build.ArtifactStagingDirectory)\release_netstandard2.0\
  - task: CopyFiles@2
    displayName: Stage Source Generator
    condition: and(succeeded(), eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildConfiguration'], 'release'))
    inputs:
      SourceFolder: $(Build.SourcesDirectory)\src\Authoring\WinRT.SourceGenerator\bin\$(BuildConfiguration)\netstandard2.0
      Contents: >-
        WinRT.SourceGenerator.dll

        WinRT.SourceGenerator.pdb
      TargetFolder: $(Build.ArtifactStagingDirectory)\release_netstandard2.0\
  - task: PublishBuildArtifacts@1
    displayName: Publish NetStandard 2.0
    condition: and(succeeded(), eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildConfiguration'], 'release'))
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)\release_netstandard2.0
      ArtifactName: netstandard2.0
  - task: CopyFiles@2
    displayName: Stage Net5.0
    condition: and(succeeded(), eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildConfiguration'], 'release'))
    inputs:
      SourceFolder: $(Build.SourcesDirectory)\src\WinRT.Runtime\bin\$(BuildConfiguration)\net5.0
      Contents: >-
        WinRT.Runtime.dll

        WinRT.Runtime.pdb
      TargetFolder: $(Build.ArtifactStagingDirectory)\release_net5.0
  - task: CopyFiles@2
    displayName: Stage WinRT.Host.Shim
    condition: and(succeeded(), eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildConfiguration'], 'release'))
    continueOnError: True
    inputs:
      SourceFolder: $(Build.SourcesDirectory)\src\Authoring\WinRT.Host.Shim\bin\$(BuildConfiguration)\net5.0
      Contents: >-
        WinRT.Host.Shim.dll

        WinRT.Host.Shim.pdb
      TargetFolder: $(Build.ArtifactStagingDirectory)\release_net5.0
  - task: CopyFiles@2
    displayName: Stage IID optimizer
    condition: and(succeeded(), eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildConfiguration'], 'release'))
    continueOnError: True
    inputs:
      SourceFolder: $(Build.SourcesDirectory)\src\Perf\IIDOptimizer\bin\$(BuildConfiguration)\net5.0
      Contents: >-
        IIDOptimizer.exe

        IIDOptimizer.dll

        IIDOptimizer.deps.json

        IIDOptimizer.runtimeconfig.json

        Mono.Cecil.dll

        Mono.Cecil.Mdb.dll

        Mono.Cecil.Pdb.dll

        Mono.Cecil.Rocks.dll

        System.CommandLine.dll

        cs/System.CommandLine.resources.dll

        de/System.CommandLine.resources.dll

        es/System.CommandLine.resources.dll

        fr/System.CommandLine.resources.dll

        it/System.CommandLine.resources.dll

        ja/System.CommandLine.resources.dll

        ko/System.CommandLine.resources.dll

        pl/System.CommandLine.resources.dll

        pt-BR/System.CommandLine.resources.dll

        ru/System.CommandLine.resources.dll

        tr/System.CommandLine.resources.dll

        zh-Hans/System.CommandLine.resources.dll

        zh-Hant/System.CommandLine.resources.dll
      TargetFolder: $(Build.ArtifactStagingDirectory)\release_net5.0\IIDOptimizer
  - task: PublishBuildArtifacts@1
    displayName: Publish Net5.0
    condition: and(succeeded(), eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildConfiguration'], 'release'))
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)\release_net5.0
      ArtifactName: net5.0
  - task: DotNetCoreCLI@2
    displayName: Run Unit Tests
    condition: and(succeeded(), or(eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildPlatform'], 'x64')))
    inputs:
      command: test
      projects: 'src/Tests/UnitTest/UnitTest.csproj '
      arguments: --diag $(Build.ArtifactStagingDirectory)\unittest\test.log --no-build --logger xunit;LogFilePath=UNITTEST-$(Build.BuildNumber).xml /nologo /m /p:platform=$(BuildPlatform);configuration=$(BuildConfiguration)
      testRunTitle: Unit Tests
  - task: VSTest@2
    displayName: Run Object Lifetime Tests
    condition: and(succeeded(), or(eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildPlatform'], 'x64')))
    inputs:
      testAssemblyVer2: Tests\ObjectLifetimeTests\bin\$(BuildPlatform)\$(BuildConfiguration)\net5.0-windows10.0.19041.0\win10-$(BuildPlatform)\ObjectLifetimeTests.Lifted.build.appxrecipe
      searchFolder: $(Build.SourcesDirectory)\src
  - task: PublishBuildArtifacts@1
    displayName: Publish Test Log
    condition: and(succeeded(), or(eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildPlatform'], 'x64')))
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)\unittest
      ArtifactName: $(BuildConfiguration)_$(BuildPlatform)_UnitTest
  - task: CmdLine@2
    displayName: Run Host Tests
    condition: and(succeeded(), or(eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildPlatform'], 'x64')))
    continueOnError: True
    inputs:
      script: "dir _build\\$(BuildPlatform)\\$(BuildConfiguration)\\HostTest\\bin\n_build\\$(BuildPlatform)\\$(BuildConfiguration)\\HostTest\\bin\\HostTest.exe --gtest_output=xml:HOSTTEST-$(Build.BuildNumber).xml \nexit /b 0"
      workingDirectory: $(Build.SourcesDirectory)\src
  - task: CmdLine@2
    displayName: Run Source Generator Tests
    condition: and(succeeded(), or(eq(variables['BuildPlatform'], 'x86'), eq(variables['BuildPlatform'], 'x64')))
    continueOnError: True
    inputs:
      script: "dir _build\\$(BuildPlatform)\\$(BuildConfiguration)\\AuthoringConsumptionTest\\bin\n_build\\$(BuildPlatform)\\$(BuildConfiguration)\\AuthoringConsumptionTest\\bin\\AuthoringConsumptionTest.exe --gtest_output=xml:AUTHORINGTEST-$(Build.BuildNumber).xml \nexit /b 0"
      workingDirectory: $(Build.SourcesDirectory)\src
- job: Job_1
  displayName: Sign and Publish
  dependsOn: Job_2
  pool:
    vmImage: windows-2019
  steps:
  - checkout: self
    clean: true
    persistCredentials: True
  - task: NuGetToolInstaller@1
    displayName: Use NuGet 5.3
    continueOnError: True
    inputs:
      versionSpec: 5.3
  - task: ComponentGovernanceComponentDetection@0
    displayName: Component Detection
  - task: DownloadBuildArtifacts@0
    displayName: 'Download x86 '
    inputs:
      artifactName: release_x86
      itemPattern: ''
      downloadPath: $(Build.SourcesDirectory)
      extractTars: false
  - task: DownloadBuildArtifacts@0
    displayName: Download x64
    inputs:
      artifactName: release_x64
      itemPattern: ''
      downloadPath: $(Build.SourcesDirectory)
      extractTars: false
  - task: DownloadBuildArtifacts@0
    displayName: Download arm64
    inputs:
      artifactName: release_arm64
      itemPattern: ''
      downloadPath: $(Build.SourcesDirectory)
      extractTars: false
  - task: DownloadBuildArtifacts@0
    displayName: Download NetStandard 2.0
    inputs:
      artifactName: netstandard2.0
      itemPattern: ''
      downloadPath: $(Build.SourcesDirectory)
      extractTars: false
  - task: DownloadBuildArtifacts@0
    displayName: 'Download Net5.0 '
    inputs:
      artifactName: net5.0
      itemPattern: ''
      downloadPath: $(Build.SourcesDirectory)
      extractTars: false
  - task: CmdLine@2
    displayName: Stage Binaries
    inputs:
      script: >-
        copy release_x86\cswinrt.exe cswinrt.exe

        copy release_x86\WinRT.Interop.winmd WinRT.Interop.winmd
      workingDirectory: $(Build.SourcesDirectory)
  - task: EsrpCodeSigning@1
    displayName: ESRP CodeSigning
    inputs:
      ConnectedServiceName: 81cc6790-027c-4ef3-928d-65e8b96a691a
      FolderPath: $(Build.SourcesDirectory)
      Pattern: >-
        cswinrt.exe

        WinRT.Interop.winmd

        netstandard2.0\WinRT.Runtime.dll

        netstandard2.0\WinRT.Host.Shim.dll

        netstandard2.0\WinRT.SourceGenerator.dll

        net5.0\WinRT.Runtime.dll

        net5.0\WinRT.Host.Shim.dll

        release_x64\WinRT.Host.dll

        release_x86\WinRT.Host.dll

        release_arm64\WinRT.Host.dll

        net5.0\IIDOptimizer\IIDOptimizer.exe

        net5.0\IIDOptimizer\IIDOptimizer.dll
      UseMinimatch: true
      signConfigType: inlineSignParams
      inlineOperation: >-
        [
          {
            "keyCode": "CP-230012",
            "operationSetCode": "SigntoolSign",
            "parameters": [
              {
                "parameterName": "OpusName",
                "parameterValue": "Microsoft"
              },
              {
                "parameterName": "OpusInfo",
                "parameterValue": "http://www.microsoft.com"
              },
              {
                "parameterName": "PageHash",
                "parameterValue": "/NPH"
              },
              {
                "parameterName": "FileDigest",
                "parameterValue": "/fd sha256"
              },
              {
                "parameterName": "TimeStamp",
                "parameterValue": "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
              }
            ],
            "toolName": "signtool.exe",
            "toolVersion": "6.2.9304.0"
          }
        ]
  - task: EsrpCodeSigning@1
    displayName: ESRP CodeSigning 3rd party
    continueOnError: True
    inputs:
      ConnectedServiceName: 81cc6790-027c-4ef3-928d-65e8b96a691a
      FolderPath: $(Build.SourcesDirectory)
      Pattern: >-
        net5.0\IIDOptimizer\Mono.Cecil.dll

        net5.0\IIDOptimizer\Mono.Cecil.Mdb.dll

        net5.0\IIDOptimizer\Mono.Cecil.Pdb.dll

        net5.0\IIDOptimizer\Mono.Cecil.Rocks.dll
      UseMinimatch: true
      signConfigType: inlineSignParams
      inlineOperation: >-
        [
            {
                "KeyCode" : "CP-231522",
                "OperationCode" : "SigntoolSign",
                "Parameters" : {
                    "OpusName" : "Microsoft",
                    "OpusInfo" : "http://www.microsoft.com",
                    "Append" : "/as",
                    "FileDigest" : "/fd \"SHA256\"",
                    "PageHash" : "/NPH",
                    "TimeStamp" : "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
                },
                "ToolName" : "sign",
                "ToolVersion" : "1.0"
            },
            {
                "KeyCode" : "CP-231522",
                "OperationCode" : "SigntoolVerify",
                "Parameters" : {},
                "ToolName" : "sign",
                "ToolVersion" : "1.0"
            }
        ]
  - task: CmdLine@2
    displayName: Parse Versions
    inputs:
      script: "rem Parse the build-generated Build.BuildNumber into components that \nrem can be recombined for version resources, nuget packages, etc.\n\n@echo off\n\nrem Encode the build date/rev into a 16 bit value for resource versions\nif \"$(PrereleaseVersion)\"==\"\" (\nset RevisionBase=30000\n) else (\nset RevisionBase=0\n)\nfor /f \"tokens=4,5 delims=.\" %%i in (\"$(Build.BuildNumber)\") do set BuildMetadata=%%i.%%j & set /a BuildRevision=%RevisionBase%+(((%%i/10000)-20)*366+((%%i)%%10000)/100*31+((%%i)%%100))*10+%%j\n\nset VersionNumber=$(MajorVersion).$(MinorVersion).$(PatchVersion).%BuildRevision%\n\nif \"$(PrereleaseVersion)\"==\"\" (\nset NugetVersion=$(MajorVersion).$(MinorVersion).$(PatchVersion)\n) else (\nset NugetVersion=$(Build.BuildNumber)\n)\n\nrem Export generated version numbers back for subsequent tasks\necho ##vso[task.setvariable variable=BuildMetadata;]%BuildMetadata%\necho ##vso[task.setvariable variable=BuildRevision;]%BuildRevision%\necho ##vso[task.setvariable variable=VersionNumber;]%VersionNumber%\necho ##vso[task.setvariable variable=NugetVersion;]%NugetVersion%\n"
      workingDirectory: $(Build.SourcesDirectory)
  - task: NuGetCommand@2
    displayName: NuGet pack
    inputs:
      command: pack
      searchPatternPack: nuget/Microsoft.Windows.CsWinRT.nuspec
      configurationToPack: Release
      buildProperties: cswinrt_nuget_version=$(NugetVersion);cswinrt_exe=$(Build.SourcesDirectory)\cswinrt.exe;interop_winmd=$(Build.SourcesDirectory)\WinRT.Interop.winmd;netstandard2_runtime=$(Build.SourcesDirectory)\netstandard2.0\WinRT.Runtime.dll;net5_runtime=$(Build.SourcesDirectory)\net5.0\WinRT.Runtime.dll;source_generator=$(Build.SourcesDirectory)\netstandard2.0\WinRT.SourceGenerator.dll;winrt_shim=$(Build.SourcesDirectory)\net5.0\WinRT.Host.Shim.dll;winrt_host_x86=$(Build.SourcesDirectory)\release_x86\WinRT.Host.dll;winrt_host_x64=$(Build.SourcesDirectory)\release_x64\WinRT.Host.dll;winrt_host_arm64=$(Build.SourcesDirectory)\release_arm64\WinRT.Host.dll;guid_patch=$(Build.SourcesDirectory)\net5.0\IIDOptimizer\*.*
  - task: EsrpCodeSigning@1
    displayName: ESRP CodeSigning
    inputs:
      ConnectedServiceName: 81cc6790-027c-4ef3-928d-65e8b96a691a
      FolderPath: $(Build.ArtifactStagingDirectory)
      Pattern: '*.nupkg'
      signConfigType: inlineSignParams
      inlineOperation: >-
        [
          {
             "KeyCode" : "CP-401405",
             "OperationCode" : "NuGetSign",
             "Parameters" : {},
             "ToolName" : "sign",
             "ToolVersion" : "1.0"
          },
          {
              "KeyCode" : "CP-401405",
              "OperationCode" : "NuGetVerify",
              "Parameters" : {},
              "ToolName" : "sign",
              "ToolVersion" : "1.0"
          }
        ]
  - task: NuGetCommand@2
    displayName: NuGet push
    inputs:
      command: push
      searchPatternPush: $(Build.ArtifactStagingDirectory)/**/*.nupkg
      feedPublish: cfbb8a6b-97b7-4070-a6e8-a4081b046ae0
      externalEndpoint: 80b1372e-52e9-486d-934f-92d5590c2241
  - task: PublishPipelineArtifact@1
    displayName: NuGet publish
    inputs:
      path: $(Build.ArtifactStagingDirectory)
      artifactName: Publish
  - task: PublishSymbols@2
    displayName: Publish Symbols
    inputs:
      SearchPattern: '**/*.pdb'
      IndexSources: false
      SymbolServerType: TeamServices
      SymbolsProduct: C#/WinRT
- job: Job_3
  displayName: WinUI Build
  dependsOn: Job_1
  pool:
    vmImage: windows-2019
  steps:
  - checkout: self
    clean: true
    persistCredentials: True
  - task: CmdLine@2
    displayName: Parse Versions
    inputs:
      script: "rem Parse the build-generated Build.BuildNumber into components that \nrem can be recombined for version resources, nuget packages, etc.\n\n@echo off\n\nrem Encode the build date/rev into a 16 bit value for resource versions\nif \"$(PrereleaseVersion)\"==\"\" (\nset RevisionBase=30000\n) else (\nset RevisionBase=0\n)\nfor /f \"tokens=4,5 delims=.\" %%i in (\"$(Build.BuildNumber)\") do set BuildMetadata=%%i.%%j & set /a BuildRevision=%RevisionBase%+(((%%i/10000)-20)*366+((%%i)%%10000)/100*31+((%%i)%%100))*10+%%j\n\nset VersionNumber=$(MajorVersion).$(MinorVersion).$(PatchVersion).%BuildRevision%\n\nif \"$(PrereleaseVersion)\"==\"\" (\nset NugetVersion=$(MajorVersion).$(MinorVersion).$(PatchVersion)\n) else (\nset NugetVersion=$(Build.BuildNumber)\n)\n\nrem Export generated version numbers back for subsequent tasks\necho ##vso[task.setvariable variable=BuildMetadata;]%BuildMetadata%\necho ##vso[task.setvariable variable=BuildRevision;]%BuildRevision%\necho ##vso[task.setvariable variable=VersionNumber;]%VersionNumber%\necho ##vso[task.setvariable variable=NugetVersion;]%NugetVersion%"
      workingDirectory: $(Build.SourcesDirectory)
  - task: PowerShell@2
    displayName: Run WinUI UpdateCSWinRT Pipeline
    continueOnError: True
    inputs:
      targetType: inline
      script: >-
        # If we're doing a release, cut a WinUI PR

        if ("$(PrereleaseVersion)" -eq "")

        {
          $updateCsWinRTPipelineID = 58312
          $branch = "master"
          $runInfo = (az pipelines run `
            --organization https://dev.azure.com/microsoft `
            --project WinUI `
            --id $updateCsWinRTPipelineID `
            --branch $branch) | ConvertFrom-Json

          $buildUrl = $runInfo.url.Replace("_apis/build/Builds/","_build/results?buildId=")

          Start-Process $buildUrl
        }


        # On a nightly, we want to just trigger a CI build

        if ($($env:reason) -eq "Schedule")

        {
          $WinUICIPipelineID = 38157
          $branch = "master"
          $runInfo = (az pipelines run `
            --organization https://dev.azure.com/microsoft `
            --project WinUI `
            --id $WinUICIPipelineID `
            --branch $branch `
            --variables "privateCsWinRTNupkgVersion=$($env:cswinrtVersion)") | ConvertFrom-Json

          $buildUrl = $runInfo.url.Replace("_apis/build/Builds/","_build/results?buildId=")

          Start-Process $buildUrl
        }
      errorActionPreference: continue
      ignoreLASTEXITCODE: true
...
