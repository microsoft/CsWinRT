// Modern IDL 3.0: https://docs.microsoft.com/en-us/uwp/midl-3/intro

// TestComponentCSharp exercises cases specific to the C# language projection
// TestWinRT.TestComponent exercises cases general to all WinRT language projections

namespace TestComponentCSharp
{
    // Event handlers
    delegate void EventHandler0();
    delegate void EventHandler1(Class sender);
    delegate void EventHandler2(Class sender, Int32 arg0);
    delegate void EventHandler3(Class sender, Int32 arg0, String arg1);
    delegate void EventHandlerCollection(Class sender, Windows.Foundation.Collections.IVector<Int32> arg0, Windows.Foundation.Collections.IMap<Int32, String> arg1);

    struct BlittableStruct
    {
        Int32 i32;
    };

    struct ComposedBlittableStruct
    {
        BlittableStruct blittable;
    };

    struct NonBlittableStringStruct
    {
        String str;
    };

    struct NonBlittableBoolStruct
    {
        // Default C# behavior is to marshal as 32-bits, hence multiple values
        Boolean w;
        Boolean x;
        Boolean y;
        Boolean z;
    };

    struct NonBlittableRefStruct
    {
        Windows.Foundation.IReference<Int32> ref32;
    };

    struct ComposedNonBlittableStruct
    {
        BlittableStruct blittable;
        NonBlittableStringStruct strings;
        NonBlittableBoolStruct bools;
        NonBlittableRefStruct refs;
    };

    delegate Int32 ProvideInt();
    delegate Boolean ProvideBool();
    delegate String ProvideString();
    delegate Object ProvideObject();

    interface ICowboy
    {
        void Draw();
        void Draw(String gunModel);
        String DrawTo();
    }

    interface IArtist
    {
        void Draw();
        void Draw(Int32 figureSides);
        Int32 DrawTo();
    }

    interface IProperties1
    {
        Int32 ReadWriteProperty{ get; };
        //Int32 DisjointProperty{ get; };
        //Int32 DistinctProperty{ get; };
    }

    interface IProperties2 requires IProperties1
    {
        Int32 ReadWriteProperty{ set; };
        //String DisjointProperty{ set; };
        //String DistinctProperty{ get; set; };
    }

    static runtimeclass StaticClass
    {
        static Class MakeClass();
        static Int32 NumClasses{ get; };
    }

    [default_interface]
    runtimeclass Class :
        Windows.Foundation.IStringable
        //, ICowboy
        //, IArtist
        , IProperties1
        , IProperties2
        //, Windows.Foundation.Collections.IVector<String>
        //, Windows.Foundation.Collections.IMap<Int32, String>
    {
        // factory
        Class();
        Class(Int32 intProperty);
        Class(Int32 intProperty, String stringProperty);

        // static
        static Int32 StaticIntProperty;
        static event Windows.Foundation.EventHandler<Int32> StaticIntPropertyChanged;
        static String StaticStringProperty;
        static event Windows.Foundation.TypedEventHandler<Class, String> StaticStringPropertyChanged;
        static void StaticGetString();
        static void StaticSetString(ProvideString provideString);
        static Int32 StaticReadWriteProperty{ get; };
        static Int32 StaticReadWriteProperty{ set; };
        static Windows.Foundation.TimeSpan FromSeconds(Int32 seconds);
        static Windows.Foundation.DateTime Now();

        // class
        event EventHandler0 Event0;
        void InvokeEvent0();
        event EventHandler1 Event1;
        void InvokeEvent1(Class sender);
        event EventHandler2 Event2;
        void InvokeEvent2(Class sender, Int32 arg0);
        event EventHandler3 Event3;
        void InvokeEvent3(Class sender, Int32 arg0, String arg1);
        event EventHandlerCollection CollectionEvent;
        void InvokeCollectionEvent(Class sender, Windows.Foundation.Collections.IVector<Int32> arg0, Windows.Foundation.Collections.IMap<Int32, String> arg1);
        event Windows.Foundation.EventHandler<Windows.Foundation.Collections.IVector<Int32> > NestedEvent;
        void InvokeNestedEvent(Class sender, Windows.Foundation.Collections.IVector<Int32> arg0);
        event Windows.Foundation.TypedEventHandler<Class, Windows.Foundation.Collections.IVector<String> > NestedTypedEvent;
        void InvokeNestedTypedEvent(Class sender, Windows.Foundation.Collections.IVector<String> arg0);

        Int32 IntProperty;
        event Windows.Foundation.EventHandler<Int32> IntPropertyChanged;
        void RaiseIntChanged();
        void CallForInt(ProvideInt provideInt);

        Boolean BoolProperty;
        event Windows.Foundation.EventHandler<Boolean> BoolPropertyChanged;
        void RaiseBoolChanged();
        void CallForBool(ProvideBool provideBool);

        String StringProperty;
        event Windows.Foundation.TypedEventHandler<Class, String> StringPropertyChanged;
        void RaiseStringChanged();
        void CallForString(ProvideString provideString);

        String StringProperty2;
        Windows.Foundation.Collections.IVector<String> StringsProperty;

        Object ObjectProperty;
        void RaiseObjectChanged();
        void CallForObject(ProvideObject provideObject);
        event Windows.Foundation.EventHandler<Object> ObjectPropertyChanged;

        // Structs
        BlittableStruct BlittableStructProperty;
        BlittableStruct GetBlittableStruct();
        void OutBlittableStruct(out BlittableStruct value);
        void SetBlittableStruct(BlittableStruct value);

        ComposedBlittableStruct ComposedBlittableStructProperty;
        ComposedBlittableStruct GetComposedBlittableStruct();
        void OutComposedBlittableStruct(out ComposedBlittableStruct value);
        void SetComposedBlittableStruct(ComposedBlittableStruct value);

        NonBlittableStringStruct NonBlittableStringStructProperty;
        NonBlittableStringStruct GetNonBlittableStringStruct();
        void OutNonBlittableStringStruct(out NonBlittableStringStruct value);
        void SetNonBlittableStringStruct(NonBlittableStringStruct value);

        NonBlittableBoolStruct NonBlittableBoolStructProperty;
        NonBlittableBoolStruct GetNonBlittableBoolStruct();
        void OutNonBlittableBoolStruct(out NonBlittableBoolStruct value);
        void SetNonBlittableBoolStruct(NonBlittableBoolStruct value);

        NonBlittableRefStruct NonBlittableRefStructProperty;
        NonBlittableRefStruct GetNonBlittableRefStruct();
        void OutNonBlittableRefStruct(out NonBlittableRefStruct value);
        void SetNonBlittableRefStruct(NonBlittableRefStruct value);

        ComposedNonBlittableStruct ComposedNonBlittableStructProperty;
        ComposedNonBlittableStruct GetComposedNonBlittableStruct();
        void OutComposedNonBlittableStruct(out ComposedNonBlittableStruct value);
        void SetComposedNonBlittableStruct(ComposedNonBlittableStruct value);

        // Arrays
        void SetInts(Int32[] ints);
        Int32[] GetInts();
        void FillInts(ref Int32[] ints);

        // Generics
        Windows.Foundation.IAsyncOperation<Int32> GetIntAsync();
        Windows.Foundation.IAsyncOperationWithProgress<String, Int32> GetStringAsync();
        Windows.Foundation.Collections.IVectorView<Int32> GetIntVector();
        Windows.Foundation.Collections.IVectorView<Boolean> GetBoolVector();
        Windows.Foundation.Collections.IVectorView<String> GetStringVector();
        Windows.Foundation.Collections.IVectorView<ComposedBlittableStruct> GetBlittableStructVector();
        Windows.Foundation.Collections.IVectorView<ComposedNonBlittableStruct> GetNonBlittableStructVector();
        Windows.Foundation.Collections.IVectorView<Object> GetObjectVector();
        Windows.Foundation.Collections.IVectorView<IProperties1> GetInterfaceVector();
        Windows.Foundation.Collections.IVectorView<Class> GetClassVector();

        void CopyProperties(IProperties1 src);
        void CopyPropertiesViaWeakReference(IProperties1 src);
        // Async
        void CompleteAsync(); // Completes the in-flight async operation successfully
        void CompleteAsync(Int32 hr); // Completes the in-flight async operation with a failed HRESULT
        void AdvanceAsync(Int32 delta); // "Advances" the progress of an in-flight IAsync*WithProgress by an amount
        Windows.Foundation.IAsyncAction DoitAsync();
        Windows.Foundation.IAsyncActionWithProgress<Int32> DoitAsyncWithProgress();
        Windows.Foundation.IAsyncOperation<Int32> AddAsync(Int32 lhs, Int32 rhs);
        Windows.Foundation.IAsyncOperationWithProgress<Int32, Int32> AddAsyncWithProgress(Int32 lhs, Int32 rhs);

        // Type mappings
        // "Simple" structs (blittable with changes to add properties/functions/constructors/etc.)
        Windows.Foundation.Point PointProperty;
        Windows.Foundation.IReference<Windows.Foundation.Point> GetPointReference();
        // Structs mapped to equivalent ones in the System namespace
        Windows.Foundation.TimeSpan TimeSpanProperty;
        Windows.Foundation.IReference<Windows.Foundation.TimeSpan> GetTimeSpanReference();
        Windows.Foundation.DateTime DateTimeProperty;
        Windows.Foundation.IReference<Windows.Foundation.DateTime> GetDateTimeProperty();
        // HResult->Exception type mapping
        Windows.Foundation.HResult HResultProperty;

        // Boxing
        static Int32 UnboxInt32(Object obj);
        static Boolean UnboxBoolean(Object obj);
        static String UnboxString(Object obj);
        static Int32[] UnboxInt32Array(Object obj);
        static Boolean[] UnboxBooleanArray(Object obj);
        static String[] UnboxStringArray(Object obj);

        // WUX.Interop.TypeName -> System.Type mapping
        static Windows.UI.Xaml.Interop.TypeName Int32Type { get; };
        static Windows.UI.Xaml.Interop.TypeName ThisClassType { get; };
        static Windows.UI.Xaml.Interop.TypeName ReferenceInt32Type { get; };

        static Boolean VerifyTypeIsInt32Type(Windows.UI.Xaml.Interop.TypeName type);
        static Boolean VerifyTypeIsThisClassType(Windows.UI.Xaml.Interop.TypeName type);
        static Boolean VerifyTypeIsReferenceInt32Type(Windows.UI.Xaml.Interop.TypeName type);
    }
}
